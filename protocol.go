// Code generated by go generate; DO NOT EDIT.
// Chrome protocol v1.3
// 2020-04-15T12:39:53Z
package gochrome

import (
	"encoding/json"
	"fmt"
	"reflect"
)

func isZero(v interface{}) bool {
	vType := reflect.TypeOf(v)
	vZero := reflect.Zero(vType)
	return v == nil || reflect.DeepEqual(v, vZero.Interface())
}


type AccessibilityAXNodeId string

type AccessibilityAXValueType string

type AccessibilityAXValueSourceType string

type AccessibilityAXValueNativeSourceType string

type AccessibilityAXValueSource map[string]interface{}

type AccessibilityAXRelatedNode map[string]interface{}

type AccessibilityAXProperty map[string]interface{}

type AccessibilityAXValue map[string]interface{}

type AccessibilityAXPropertyName string

type AccessibilityAXNode map[string]interface{}

type AnimationAnimation map[string]interface{}

type AnimationAnimationEffect map[string]interface{}

type AnimationKeyframesRule map[string]interface{}

type AnimationKeyframeStyle map[string]interface{}

type ApplicationCacheApplicationCacheResource map[string]interface{}

type ApplicationCacheApplicationCache map[string]interface{}

type ApplicationCacheFrameWithManifest map[string]interface{}

type BackgroundServiceServiceName string

type BackgroundServiceEventMetadata map[string]interface{}

type BackgroundServiceBackgroundServiceEvent map[string]interface{}

type BrowserBrowserContextID string

type BrowserWindowID int

type BrowserWindowState string

type BrowserBounds map[string]interface{}

type BrowserPermissionType string

type BrowserPermissionSetting string

type BrowserPermissionDescriptor map[string]interface{}

type BrowserBucket map[string]interface{}

type BrowserHistogram map[string]interface{}

type CSSStyleSheetId string

type CSSStyleSheetOrigin string

type CSSPseudoElementMatches map[string]interface{}

type CSSInheritedStyleEntry map[string]interface{}

type CSSRuleMatch map[string]interface{}

type CSSValue map[string]interface{}

type CSSSelectorList map[string]interface{}

type CSSCSSStyleSheetHeader map[string]interface{}

type CSSCSSRule map[string]interface{}

type CSSRuleUsage map[string]interface{}

type CSSSourceRange map[string]interface{}

type CSSShorthandEntry map[string]interface{}

type CSSCSSComputedStyleProperty map[string]interface{}

type CSSCSSStyle map[string]interface{}

type CSSCSSProperty map[string]interface{}

type CSSCSSMedia map[string]interface{}

type CSSMediaQuery map[string]interface{}

type CSSMediaQueryExpression map[string]interface{}

type CSSPlatformFontUsage map[string]interface{}

type CSSFontFace map[string]interface{}

type CSSCSSKeyframesRule map[string]interface{}

type CSSCSSKeyframeRule map[string]interface{}

type CSSStyleDeclarationEdit map[string]interface{}

type CacheStorageCacheId string

type CacheStorageCachedResponseType string

type CacheStorageDataEntry map[string]interface{}

type CacheStorageCache map[string]interface{}

type CacheStorageHeader map[string]interface{}

type CacheStorageCachedResponse map[string]interface{}

type CastSink map[string]interface{}

type DOMNodeId int

type DOMBackendNodeId int

type DOMBackendNode map[string]interface{}

type DOMPseudoType string

type DOMShadowRootType string

type DOMNode map[string]interface{}

type DOMRGBA map[string]interface{}

type DOMQuad []interface{}

type DOMBoxModel map[string]interface{}

type DOMShapeOutsideInfo map[string]interface{}

type DOMRect map[string]interface{}

type DOMDebuggerDOMBreakpointType string

type DOMDebuggerEventListener map[string]interface{}

type DOMSnapshotDOMNode map[string]interface{}

type DOMSnapshotInlineTextBox map[string]interface{}

type DOMSnapshotLayoutTreeNode map[string]interface{}

type DOMSnapshotComputedStyle map[string]interface{}

type DOMSnapshotNameValue map[string]interface{}

type DOMSnapshotStringIndex int

type DOMSnapshotArrayOfStrings []interface{}

type DOMSnapshotRareStringData map[string]interface{}

type DOMSnapshotRareBooleanData map[string]interface{}

type DOMSnapshotRareIntegerData map[string]interface{}

type DOMSnapshotRectangle []interface{}

type DOMSnapshotDocumentSnapshot map[string]interface{}

type DOMSnapshotNodeTreeSnapshot map[string]interface{}

type DOMSnapshotLayoutTreeSnapshot map[string]interface{}

type DOMSnapshotTextBoxSnapshot map[string]interface{}

type DOMStorageStorageId map[string]interface{}

type DOMStorageItem []interface{}

type DatabaseDatabaseId string

type DatabaseDatabase map[string]interface{}

type DatabaseError map[string]interface{}

type EmulationScreenOrientation map[string]interface{}

type EmulationMediaFeature map[string]interface{}

type EmulationVirtualTimePolicy string

type HeadlessExperimentalScreenshotParams map[string]interface{}

type IOStreamHandle string

type IndexedDBDatabaseWithObjectStores map[string]interface{}

type IndexedDBObjectStore map[string]interface{}

type IndexedDBObjectStoreIndex map[string]interface{}

type IndexedDBKey map[string]interface{}

type IndexedDBKeyRange map[string]interface{}

type IndexedDBDataEntry map[string]interface{}

type IndexedDBKeyPath map[string]interface{}

type InputTouchPoint map[string]interface{}

type InputGestureSourceType string

type InputTimeSinceEpoch float64

type LayerTreeLayerId string

type LayerTreeSnapshotId string

type LayerTreeScrollRect map[string]interface{}

type LayerTreeStickyPositionConstraint map[string]interface{}

type LayerTreePictureTile map[string]interface{}

type LayerTreeLayer map[string]interface{}

type LayerTreePaintProfile []interface{}

type LogLogEntry map[string]interface{}

type LogViolationSetting map[string]interface{}

type MemoryPressureLevel string

type MemorySamplingProfileNode map[string]interface{}

type MemorySamplingProfile map[string]interface{}

type MemoryModule map[string]interface{}

type NetworkResourceType string

type NetworkLoaderId string

type NetworkRequestId string

type NetworkInterceptionId string

type NetworkErrorReason string

type NetworkTimeSinceEpoch float64

type NetworkMonotonicTime float64

type NetworkHeaders map[string]interface{}

type NetworkConnectionType string

type NetworkCookieSameSite string

type NetworkResourceTiming map[string]interface{}

type NetworkResourcePriority string

type NetworkRequest map[string]interface{}

type NetworkSignedCertificateTimestamp map[string]interface{}

type NetworkSecurityDetails map[string]interface{}

type NetworkCertificateTransparencyCompliance string

type NetworkBlockedReason string

type NetworkResponse map[string]interface{}

type NetworkWebSocketRequest map[string]interface{}

type NetworkWebSocketResponse map[string]interface{}

type NetworkWebSocketFrame map[string]interface{}

type NetworkCachedResource map[string]interface{}

type NetworkInitiator map[string]interface{}

type NetworkCookie map[string]interface{}

type NetworkSetCookieBlockedReason string

type NetworkCookieBlockedReason string

type NetworkBlockedSetCookieWithReason map[string]interface{}

type NetworkBlockedCookieWithReason map[string]interface{}

type NetworkCookieParam map[string]interface{}

type NetworkAuthChallenge map[string]interface{}

type NetworkAuthChallengeResponse map[string]interface{}

type NetworkInterceptionStage string

type NetworkRequestPattern map[string]interface{}

type NetworkSignedExchangeSignature map[string]interface{}

type NetworkSignedExchangeHeader map[string]interface{}

type NetworkSignedExchangeErrorField string

type NetworkSignedExchangeError map[string]interface{}

type NetworkSignedExchangeInfo map[string]interface{}

type OverlayHighlightConfig map[string]interface{}

type OverlayInspectMode string

type PageFrameId string

type PageFrame map[string]interface{}

type PageFrameResource map[string]interface{}

type PageFrameResourceTree map[string]interface{}

type PageFrameTree map[string]interface{}

type PageScriptIdentifier string

type PageTransitionType string

type PageNavigationEntry map[string]interface{}

type PageScreencastFrameMetadata map[string]interface{}

type PageDialogType string

type PageAppManifestError map[string]interface{}

type PageLayoutViewport map[string]interface{}

type PageVisualViewport map[string]interface{}

type PageViewport map[string]interface{}

type PageFontFamilies map[string]interface{}

type PageFontSizes map[string]interface{}

type PageClientNavigationReason string

type PerformanceMetric map[string]interface{}

type SecurityCertificateId int

type SecurityMixedContentType string

type SecuritySecurityState string

type SecurityCertificateSecurityState map[string]interface{}

type SecuritySafetyTipStatus string

type SecuritySafetyTipInfo map[string]interface{}

type SecurityVisibleSecurityState map[string]interface{}

type SecuritySecurityStateExplanation map[string]interface{}

type SecurityInsecureContentStatus map[string]interface{}

type SecurityCertificateErrorAction string

type ServiceWorkerRegistrationID string

type ServiceWorkerServiceWorkerRegistration map[string]interface{}

type ServiceWorkerServiceWorkerVersionRunningStatus string

type ServiceWorkerServiceWorkerVersionStatus string

type ServiceWorkerServiceWorkerVersion map[string]interface{}

type ServiceWorkerServiceWorkerErrorMessage map[string]interface{}

type StorageStorageType string

type StorageUsageForType map[string]interface{}

type SystemInfoGPUDevice map[string]interface{}

type SystemInfoSize map[string]interface{}

type SystemInfoVideoDecodeAcceleratorCapability map[string]interface{}

type SystemInfoVideoEncodeAcceleratorCapability map[string]interface{}

type SystemInfoSubsamplingFormat string

type SystemInfoImageType string

type SystemInfoImageDecodeAcceleratorCapability map[string]interface{}

type SystemInfoGPUInfo map[string]interface{}

type SystemInfoProcessInfo map[string]interface{}

type TargetTargetID string

type TargetSessionID string

type TargetTargetInfo map[string]interface{}

type TargetRemoteLocation map[string]interface{}

type TracingMemoryDumpConfig map[string]interface{}

type TracingTraceConfig map[string]interface{}

type TracingStreamFormat string

type TracingStreamCompression string

type FetchRequestId string

type FetchRequestStage string

type FetchRequestPattern map[string]interface{}

type FetchHeaderEntry map[string]interface{}

type FetchAuthChallenge map[string]interface{}

type FetchAuthChallengeResponse map[string]interface{}

type WebAudioGraphObjectId string

type WebAudioContextType string

type WebAudioContextState string

type WebAudioNodeType string

type WebAudioChannelCountMode string

type WebAudioChannelInterpretation string

type WebAudioParamType string

type WebAudioAutomationRate string

type WebAudioContextRealtimeData map[string]interface{}

type WebAudioBaseAudioContext map[string]interface{}

type WebAudioAudioListener map[string]interface{}

type WebAudioAudioNode map[string]interface{}

type WebAudioAudioParam map[string]interface{}

type WebAuthnAuthenticatorId string

type WebAuthnAuthenticatorProtocol string

type WebAuthnAuthenticatorTransport string

type WebAuthnVirtualAuthenticatorOptions map[string]interface{}

type WebAuthnCredential map[string]interface{}

type MediaPlayerId string

type MediaTimestamp float64

type MediaPlayerProperty map[string]interface{}

type MediaPlayerEventType string

type MediaPlayerEvent map[string]interface{}

type ConsoleConsoleMessage map[string]interface{}

type DebuggerBreakpointId string

type DebuggerCallFrameId string

type DebuggerLocation map[string]interface{}

type DebuggerScriptPosition map[string]interface{}

type DebuggerCallFrame map[string]interface{}

type DebuggerScope map[string]interface{}

type DebuggerSearchMatch map[string]interface{}

type DebuggerBreakLocation map[string]interface{}

type HeapProfilerHeapSnapshotObjectId string

type HeapProfilerSamplingHeapProfileNode map[string]interface{}

type HeapProfilerSamplingHeapProfileSample map[string]interface{}

type HeapProfilerSamplingHeapProfile map[string]interface{}

type ProfilerProfileNode map[string]interface{}

type ProfilerProfile map[string]interface{}

type ProfilerPositionTickInfo map[string]interface{}

type ProfilerCoverageRange map[string]interface{}

type ProfilerFunctionCoverage map[string]interface{}

type ProfilerScriptCoverage map[string]interface{}

type ProfilerTypeObject map[string]interface{}

type ProfilerTypeProfileEntry map[string]interface{}

type ProfilerScriptTypeProfile map[string]interface{}

type ProfilerCounterInfo map[string]interface{}

type RuntimeScriptId string

type RuntimeRemoteObjectId string

type RuntimeUnserializableValue string

type RuntimeRemoteObject map[string]interface{}

type RuntimeCustomPreview map[string]interface{}

type RuntimeObjectPreview map[string]interface{}

type RuntimePropertyPreview map[string]interface{}

type RuntimeEntryPreview map[string]interface{}

type RuntimePropertyDescriptor map[string]interface{}

type RuntimeInternalPropertyDescriptor map[string]interface{}

type RuntimePrivatePropertyDescriptor map[string]interface{}

type RuntimeCallArgument map[string]interface{}

type RuntimeExecutionContextId int

type RuntimeExecutionContextDescription map[string]interface{}

type RuntimeExceptionDetails map[string]interface{}

type RuntimeTimestamp float64

type RuntimeTimeDelta float64

type RuntimeCallFrame map[string]interface{}

type RuntimeStackTrace map[string]interface{}

type RuntimeUniqueDebuggerId string

type RuntimeStackTraceId map[string]interface{}

type SchemaDomain map[string]interface{}


type AccessibilityDisableReturns struct {
	
}

/* Disables the accessibility domain. */
func (t *Tab) AccessibilityDisable() (AccessibilityDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Accessibility.disable",
		"params": params_,
	})

	var returns_ AccessibilityDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AccessibilityEnableReturns struct {
	
}

/* Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
This turns on accessibility for the page, which can impact performance until accessibility is disabled. */
func (t *Tab) AccessibilityEnable() (AccessibilityEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Accessibility.enable",
		"params": params_,
	})

	var returns_ AccessibilityEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AccessibilityGetPartialAXTreeReturns struct {
	
	Nodes []AccessibilityAXNode
	
}

/* Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists. */
func (t *Tab) AccessibilityGetPartialAXTree(nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId, fetchRelatives bool) (AccessibilityGetPartialAXTreeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	
	
	if !isZero(fetchRelatives) {
		params_["fetchRelatives"] = fetchRelatives
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Accessibility.getPartialAXTree",
		"params": params_,
	})

	var returns_ AccessibilityGetPartialAXTreeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AccessibilityGetFullAXTreeReturns struct {
	
	Nodes []AccessibilityAXNode
	
}

/* Fetches the entire accessibility tree */
func (t *Tab) AccessibilityGetFullAXTree() (AccessibilityGetFullAXTreeReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Accessibility.getFullAXTree",
		"params": params_,
	})

	var returns_ AccessibilityGetFullAXTreeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationDisableReturns struct {
	
}

/* Disables animation domain notifications. */
func (t *Tab) AnimationDisable() (AnimationDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.disable",
		"params": params_,
	})

	var returns_ AnimationDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationEnableReturns struct {
	
}

/* Enables animation domain notifications. */
func (t *Tab) AnimationEnable() (AnimationEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.enable",
		"params": params_,
	})

	var returns_ AnimationEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationGetCurrentTimeReturns struct {
	
	CurrentTime float64
	
}

/* Returns the current time of the an animation. */
func (t *Tab) AnimationGetCurrentTime(id string) (AnimationGetCurrentTimeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["id"] = id
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.getCurrentTime",
		"params": params_,
	})

	var returns_ AnimationGetCurrentTimeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationGetPlaybackRateReturns struct {
	
	PlaybackRate float64
	
}

/* Gets the playback rate of the document timeline. */
func (t *Tab) AnimationGetPlaybackRate() (AnimationGetPlaybackRateReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.getPlaybackRate",
		"params": params_,
	})

	var returns_ AnimationGetPlaybackRateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationReleaseAnimationsReturns struct {
	
}

/* Releases a set of animations to no longer be manipulated. */
func (t *Tab) AnimationReleaseAnimations(animations []string) (AnimationReleaseAnimationsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["animations"] = animations
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.releaseAnimations",
		"params": params_,
	})

	var returns_ AnimationReleaseAnimationsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationResolveAnimationReturns struct {
	
	RemoteObject RuntimeRemoteObject
	
}

/* Gets the remote object of the Animation. */
func (t *Tab) AnimationResolveAnimation(animationId string) (AnimationResolveAnimationReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["animationId"] = animationId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.resolveAnimation",
		"params": params_,
	})

	var returns_ AnimationResolveAnimationReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationSeekAnimationsReturns struct {
	
}

/* Seek a set of animations to a particular time within each animation. */
func (t *Tab) AnimationSeekAnimations(animations []string, currentTime float64) (AnimationSeekAnimationsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["animations"] = animations
	
	
	
	params_["currentTime"] = currentTime
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.seekAnimations",
		"params": params_,
	})

	var returns_ AnimationSeekAnimationsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationSetPausedReturns struct {
	
}

/* Sets the paused state of a set of animations. */
func (t *Tab) AnimationSetPaused(animations []string, paused bool) (AnimationSetPausedReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["animations"] = animations
	
	
	
	params_["paused"] = paused
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.setPaused",
		"params": params_,
	})

	var returns_ AnimationSetPausedReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationSetPlaybackRateReturns struct {
	
}

/* Sets the playback rate of the document timeline. */
func (t *Tab) AnimationSetPlaybackRate(playbackRate float64) (AnimationSetPlaybackRateReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["playbackRate"] = playbackRate
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.setPlaybackRate",
		"params": params_,
	})

	var returns_ AnimationSetPlaybackRateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AnimationSetTimingReturns struct {
	
}

/* Sets the timing of an animation node. */
func (t *Tab) AnimationSetTiming(animationId string, duration float64, delay float64) (AnimationSetTimingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["animationId"] = animationId
	
	
	
	params_["duration"] = duration
	
	
	
	params_["delay"] = delay
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Animation.setTiming",
		"params": params_,
	})

	var returns_ AnimationSetTimingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ApplicationCacheEnableReturns struct {
	
}

/* Enables application cache domain notifications. */
func (t *Tab) ApplicationCacheEnable() (ApplicationCacheEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ApplicationCache.enable",
		"params": params_,
	})

	var returns_ ApplicationCacheEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ApplicationCacheGetApplicationCacheForFrameReturns struct {
	
	ApplicationCache ApplicationCacheApplicationCache
	
}

/* Returns relevant application cache data for the document in given frame. */
func (t *Tab) ApplicationCacheGetApplicationCacheForFrame(frameId PageFrameId) (ApplicationCacheGetApplicationCacheForFrameReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ApplicationCache.getApplicationCacheForFrame",
		"params": params_,
	})

	var returns_ ApplicationCacheGetApplicationCacheForFrameReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ApplicationCacheGetFramesWithManifestsReturns struct {
	
	FrameIds []ApplicationCacheFrameWithManifest
	
}

/* Returns array of frame identifiers with manifest urls for each frame containing a document
associated with some application cache. */
func (t *Tab) ApplicationCacheGetFramesWithManifests() (ApplicationCacheGetFramesWithManifestsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ApplicationCache.getFramesWithManifests",
		"params": params_,
	})

	var returns_ ApplicationCacheGetFramesWithManifestsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ApplicationCacheGetManifestForFrameReturns struct {
	
	ManifestURL string
	
}

/* Returns manifest URL for document in the given frame. */
func (t *Tab) ApplicationCacheGetManifestForFrame(frameId PageFrameId) (ApplicationCacheGetManifestForFrameReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ApplicationCache.getManifestForFrame",
		"params": params_,
	})

	var returns_ ApplicationCacheGetManifestForFrameReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type AuditsGetEncodedResponseReturns struct {
	
	Body []byte
	
	OriginalSize int
	
	EncodedSize int
	
}

/* Returns the response body and size if it were re-encoded with the specified settings. Only
applies to images. */
func (t *Tab) AuditsGetEncodedResponse(requestId NetworkRequestId, encoding string, quality float64, sizeOnly bool) (AuditsGetEncodedResponseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	
	
	params_["encoding"] = encoding
	
	
	
	if !isZero(quality) {
		params_["quality"] = quality
	}
	
	
	
	if !isZero(sizeOnly) {
		params_["sizeOnly"] = sizeOnly
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Audits.getEncodedResponse",
		"params": params_,
	})

	var returns_ AuditsGetEncodedResponseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BackgroundServiceStartObservingReturns struct {
	
}

/* Enables event updates for the service. */
func (t *Tab) BackgroundServiceStartObserving(service BackgroundServiceServiceName) (BackgroundServiceStartObservingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["service"] = service
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "BackgroundService.startObserving",
		"params": params_,
	})

	var returns_ BackgroundServiceStartObservingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BackgroundServiceStopObservingReturns struct {
	
}

/* Disables event updates for the service. */
func (t *Tab) BackgroundServiceStopObserving(service BackgroundServiceServiceName) (BackgroundServiceStopObservingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["service"] = service
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "BackgroundService.stopObserving",
		"params": params_,
	})

	var returns_ BackgroundServiceStopObservingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BackgroundServiceSetRecordingReturns struct {
	
}

/* Set the recording state for the service. */
func (t *Tab) BackgroundServiceSetRecording(shouldRecord bool, service BackgroundServiceServiceName) (BackgroundServiceSetRecordingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["shouldRecord"] = shouldRecord
	
	
	
	params_["service"] = service
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "BackgroundService.setRecording",
		"params": params_,
	})

	var returns_ BackgroundServiceSetRecordingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BackgroundServiceClearEventsReturns struct {
	
}

/* Clears all stored data for the service. */
func (t *Tab) BackgroundServiceClearEvents(service BackgroundServiceServiceName) (BackgroundServiceClearEventsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["service"] = service
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "BackgroundService.clearEvents",
		"params": params_,
	})

	var returns_ BackgroundServiceClearEventsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserSetPermissionReturns struct {
	
}

/* Set permission settings for given origin. */
func (t *Tab) BrowserSetPermission(origin string, permission BrowserPermissionDescriptor, setting BrowserPermissionSetting, browserContextId BrowserBrowserContextID) (BrowserSetPermissionReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	
	
	params_["permission"] = permission
	
	
	
	params_["setting"] = setting
	
	
	
	if !isZero(browserContextId) {
		params_["browserContextId"] = browserContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.setPermission",
		"params": params_,
	})

	var returns_ BrowserSetPermissionReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserGrantPermissionsReturns struct {
	
}

/* Grant specific permissions to the given origin and reject all others. */
func (t *Tab) BrowserGrantPermissions(origin string, permissions []BrowserPermissionType, browserContextId BrowserBrowserContextID) (BrowserGrantPermissionsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	
	
	params_["permissions"] = permissions
	
	
	
	if !isZero(browserContextId) {
		params_["browserContextId"] = browserContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.grantPermissions",
		"params": params_,
	})

	var returns_ BrowserGrantPermissionsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserResetPermissionsReturns struct {
	
}

/* Reset all permission management for all origins. */
func (t *Tab) BrowserResetPermissions(browserContextId BrowserBrowserContextID) (BrowserResetPermissionsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(browserContextId) {
		params_["browserContextId"] = browserContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.resetPermissions",
		"params": params_,
	})

	var returns_ BrowserResetPermissionsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserCloseReturns struct {
	
}

/* Close browser gracefully. */
func (t *Tab) BrowserClose() (BrowserCloseReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.close",
		"params": params_,
	})

	var returns_ BrowserCloseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserCrashReturns struct {
	
}

/* Crashes browser on the main thread. */
func (t *Tab) BrowserCrash() (BrowserCrashReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.crash",
		"params": params_,
	})

	var returns_ BrowserCrashReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserCrashGpuProcessReturns struct {
	
}

/* Crashes GPU process. */
func (t *Tab) BrowserCrashGpuProcess() (BrowserCrashGpuProcessReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.crashGpuProcess",
		"params": params_,
	})

	var returns_ BrowserCrashGpuProcessReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserGetVersionReturns struct {
	
	ProtocolVersion string
	
	Product string
	
	Revision string
	
	UserAgent string
	
	JsVersion string
	
}

/* Returns version information. */
func (t *Tab) BrowserGetVersion() (BrowserGetVersionReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.getVersion",
		"params": params_,
	})

	var returns_ BrowserGetVersionReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserGetBrowserCommandLineReturns struct {
	
	Arguments []string
	
}

/* Returns the command line switches for the browser process if, and only if
--enable-automation is on the commandline. */
func (t *Tab) BrowserGetBrowserCommandLine() (BrowserGetBrowserCommandLineReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.getBrowserCommandLine",
		"params": params_,
	})

	var returns_ BrowserGetBrowserCommandLineReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserGetHistogramsReturns struct {
	
	Histograms []BrowserHistogram
	
}

/* Get Chrome histograms. */
func (t *Tab) BrowserGetHistograms(query string, delta bool) (BrowserGetHistogramsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(query) {
		params_["query"] = query
	}
	
	
	
	if !isZero(delta) {
		params_["delta"] = delta
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.getHistograms",
		"params": params_,
	})

	var returns_ BrowserGetHistogramsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserGetHistogramReturns struct {
	
	Histogram BrowserHistogram
	
}

/* Get a Chrome histogram by name. */
func (t *Tab) BrowserGetHistogram(name string, delta bool) (BrowserGetHistogramReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["name"] = name
	
	
	
	if !isZero(delta) {
		params_["delta"] = delta
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.getHistogram",
		"params": params_,
	})

	var returns_ BrowserGetHistogramReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserGetWindowBoundsReturns struct {
	
	Bounds BrowserBounds
	
}

/* Get position and size of the browser window. */
func (t *Tab) BrowserGetWindowBounds(windowId BrowserWindowID) (BrowserGetWindowBoundsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["windowId"] = windowId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.getWindowBounds",
		"params": params_,
	})

	var returns_ BrowserGetWindowBoundsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserGetWindowForTargetReturns struct {
	
	WindowId BrowserWindowID
	
	Bounds BrowserBounds
	
}

/* Get the browser window that contains the devtools target. */
func (t *Tab) BrowserGetWindowForTarget(targetId TargetTargetID) (BrowserGetWindowForTargetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(targetId) {
		params_["targetId"] = targetId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.getWindowForTarget",
		"params": params_,
	})

	var returns_ BrowserGetWindowForTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserSetWindowBoundsReturns struct {
	
}

/* Set position and/or size of the browser window. */
func (t *Tab) BrowserSetWindowBounds(windowId BrowserWindowID, bounds BrowserBounds) (BrowserSetWindowBoundsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["windowId"] = windowId
	
	
	
	params_["bounds"] = bounds
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.setWindowBounds",
		"params": params_,
	})

	var returns_ BrowserSetWindowBoundsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type BrowserSetDockTileReturns struct {
	
}

/* Set dock tile details, platform-specific. */
func (t *Tab) BrowserSetDockTile(badgeLabel string, image []byte) (BrowserSetDockTileReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(badgeLabel) {
		params_["badgeLabel"] = badgeLabel
	}
	
	
	
	if !isZero(image) {
		params_["image"] = image
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Browser.setDockTile",
		"params": params_,
	})

	var returns_ BrowserSetDockTileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSAddRuleReturns struct {
	
	Rule CSSCSSRule
	
}

/* Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
position specified by `location`. */
func (t *Tab) CSSAddRule(styleSheetId CSSStyleSheetId, ruleText string, location CSSSourceRange) (CSSAddRuleReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["styleSheetId"] = styleSheetId
	
	
	
	params_["ruleText"] = ruleText
	
	
	
	params_["location"] = location
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.addRule",
		"params": params_,
	})

	var returns_ CSSAddRuleReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSCollectClassNamesReturns struct {
	
	ClassNames []string
	
}

/* Returns all class names from specified stylesheet. */
func (t *Tab) CSSCollectClassNames(styleSheetId CSSStyleSheetId) (CSSCollectClassNamesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["styleSheetId"] = styleSheetId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.collectClassNames",
		"params": params_,
	})

	var returns_ CSSCollectClassNamesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSCreateStyleSheetReturns struct {
	
	StyleSheetId CSSStyleSheetId
	
}

/* Creates a new special "via-inspector" stylesheet in the frame with given `frameId`. */
func (t *Tab) CSSCreateStyleSheet(frameId PageFrameId) (CSSCreateStyleSheetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.createStyleSheet",
		"params": params_,
	})

	var returns_ CSSCreateStyleSheetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSDisableReturns struct {
	
}

/* Disables the CSS agent for the given page. */
func (t *Tab) CSSDisable() (CSSDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.disable",
		"params": params_,
	})

	var returns_ CSSDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSEnableReturns struct {
	
}

/* Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
enabled until the result of this command is received. */
func (t *Tab) CSSEnable() (CSSEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.enable",
		"params": params_,
	})

	var returns_ CSSEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSForcePseudoStateReturns struct {
	
}

/* Ensures that the given node will have specified pseudo-classes whenever its style is computed by
the browser. */
func (t *Tab) CSSForcePseudoState(nodeId DOMNodeId, forcedPseudoClasses []string) (CSSForcePseudoStateReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["forcedPseudoClasses"] = forcedPseudoClasses
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.forcePseudoState",
		"params": params_,
	})

	var returns_ CSSForcePseudoStateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSGetBackgroundColorsReturns struct {
	
	BackgroundColors []string
	
	ComputedFontSize string
	
	ComputedFontWeight string
	
}

/*  */
func (t *Tab) CSSGetBackgroundColors(nodeId DOMNodeId) (CSSGetBackgroundColorsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.getBackgroundColors",
		"params": params_,
	})

	var returns_ CSSGetBackgroundColorsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSGetComputedStyleForNodeReturns struct {
	
	ComputedStyle []CSSCSSComputedStyleProperty
	
}

/* Returns the computed style for a DOM node identified by `nodeId`. */
func (t *Tab) CSSGetComputedStyleForNode(nodeId DOMNodeId) (CSSGetComputedStyleForNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.getComputedStyleForNode",
		"params": params_,
	})

	var returns_ CSSGetComputedStyleForNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSGetInlineStylesForNodeReturns struct {
	
	InlineStyle CSSCSSStyle
	
	AttributesStyle CSSCSSStyle
	
}

/* Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
attributes) for a DOM node identified by `nodeId`. */
func (t *Tab) CSSGetInlineStylesForNode(nodeId DOMNodeId) (CSSGetInlineStylesForNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.getInlineStylesForNode",
		"params": params_,
	})

	var returns_ CSSGetInlineStylesForNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSGetMatchedStylesForNodeReturns struct {
	
	InlineStyle CSSCSSStyle
	
	AttributesStyle CSSCSSStyle
	
	MatchedCSSRules []CSSRuleMatch
	
	PseudoElements []CSSPseudoElementMatches
	
	Inherited []CSSInheritedStyleEntry
	
	CssKeyframesRules []CSSCSSKeyframesRule
	
}

/* Returns requested styles for a DOM node identified by `nodeId`. */
func (t *Tab) CSSGetMatchedStylesForNode(nodeId DOMNodeId) (CSSGetMatchedStylesForNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.getMatchedStylesForNode",
		"params": params_,
	})

	var returns_ CSSGetMatchedStylesForNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSGetMediaQueriesReturns struct {
	
	Medias []CSSCSSMedia
	
}

/* Returns all media queries parsed by the rendering engine. */
func (t *Tab) CSSGetMediaQueries() (CSSGetMediaQueriesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.getMediaQueries",
		"params": params_,
	})

	var returns_ CSSGetMediaQueriesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSGetPlatformFontsForNodeReturns struct {
	
	Fonts []CSSPlatformFontUsage
	
}

/* Requests information about platform fonts which we used to render child TextNodes in the given
node. */
func (t *Tab) CSSGetPlatformFontsForNode(nodeId DOMNodeId) (CSSGetPlatformFontsForNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.getPlatformFontsForNode",
		"params": params_,
	})

	var returns_ CSSGetPlatformFontsForNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSGetStyleSheetTextReturns struct {
	
	Text string
	
}

/* Returns the current textual content for a stylesheet. */
func (t *Tab) CSSGetStyleSheetText(styleSheetId CSSStyleSheetId) (CSSGetStyleSheetTextReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["styleSheetId"] = styleSheetId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.getStyleSheetText",
		"params": params_,
	})

	var returns_ CSSGetStyleSheetTextReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSSetEffectivePropertyValueForNodeReturns struct {
	
}

/* Find a rule with the given active property for the given node and set the new value for this
property */
func (t *Tab) CSSSetEffectivePropertyValueForNode(nodeId DOMNodeId, propertyName string, value string) (CSSSetEffectivePropertyValueForNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["propertyName"] = propertyName
	
	
	
	params_["value"] = value
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.setEffectivePropertyValueForNode",
		"params": params_,
	})

	var returns_ CSSSetEffectivePropertyValueForNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSSetKeyframeKeyReturns struct {
	
	KeyText CSSValue
	
}

/* Modifies the keyframe rule key text. */
func (t *Tab) CSSSetKeyframeKey(styleSheetId CSSStyleSheetId, Range CSSSourceRange, keyText string) (CSSSetKeyframeKeyReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["styleSheetId"] = styleSheetId
	
	
	
	params_["Range"] = Range
	
	
	
	params_["keyText"] = keyText
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.setKeyframeKey",
		"params": params_,
	})

	var returns_ CSSSetKeyframeKeyReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSSetMediaTextReturns struct {
	
	Media CSSCSSMedia
	
}

/* Modifies the rule selector. */
func (t *Tab) CSSSetMediaText(styleSheetId CSSStyleSheetId, Range CSSSourceRange, text string) (CSSSetMediaTextReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["styleSheetId"] = styleSheetId
	
	
	
	params_["Range"] = Range
	
	
	
	params_["text"] = text
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.setMediaText",
		"params": params_,
	})

	var returns_ CSSSetMediaTextReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSSetRuleSelectorReturns struct {
	
	SelectorList CSSSelectorList
	
}

/* Modifies the rule selector. */
func (t *Tab) CSSSetRuleSelector(styleSheetId CSSStyleSheetId, Range CSSSourceRange, selector string) (CSSSetRuleSelectorReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["styleSheetId"] = styleSheetId
	
	
	
	params_["Range"] = Range
	
	
	
	params_["selector"] = selector
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.setRuleSelector",
		"params": params_,
	})

	var returns_ CSSSetRuleSelectorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSSetStyleSheetTextReturns struct {
	
	SourceMapURL string
	
}

/* Sets the new stylesheet text. */
func (t *Tab) CSSSetStyleSheetText(styleSheetId CSSStyleSheetId, text string) (CSSSetStyleSheetTextReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["styleSheetId"] = styleSheetId
	
	
	
	params_["text"] = text
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.setStyleSheetText",
		"params": params_,
	})

	var returns_ CSSSetStyleSheetTextReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSSetStyleTextsReturns struct {
	
	Styles []CSSCSSStyle
	
}

/* Applies specified style edits one after another in the given order. */
func (t *Tab) CSSSetStyleTexts(edits []CSSStyleDeclarationEdit) (CSSSetStyleTextsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["edits"] = edits
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.setStyleTexts",
		"params": params_,
	})

	var returns_ CSSSetStyleTextsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSStartRuleUsageTrackingReturns struct {
	
}

/* Enables the selector recording. */
func (t *Tab) CSSStartRuleUsageTracking() (CSSStartRuleUsageTrackingReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.startRuleUsageTracking",
		"params": params_,
	})

	var returns_ CSSStartRuleUsageTrackingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSStopRuleUsageTrackingReturns struct {
	
	RuleUsage []CSSRuleUsage
	
}

/* Stop tracking rule usage and return the list of rules that were used since last call to
`takeCoverageDelta` (or since start of coverage instrumentation) */
func (t *Tab) CSSStopRuleUsageTracking() (CSSStopRuleUsageTrackingReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.stopRuleUsageTracking",
		"params": params_,
	})

	var returns_ CSSStopRuleUsageTrackingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CSSTakeCoverageDeltaReturns struct {
	
	Coverage []CSSRuleUsage
	
}

/* Obtain list of rules that became used since last call to this method (or since start of coverage
instrumentation) */
func (t *Tab) CSSTakeCoverageDelta() (CSSTakeCoverageDeltaReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CSS.takeCoverageDelta",
		"params": params_,
	})

	var returns_ CSSTakeCoverageDeltaReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CacheStorageDeleteCacheReturns struct {
	
}

/* Deletes a cache. */
func (t *Tab) CacheStorageDeleteCache(cacheId CacheStorageCacheId) (CacheStorageDeleteCacheReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cacheId"] = cacheId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CacheStorage.deleteCache",
		"params": params_,
	})

	var returns_ CacheStorageDeleteCacheReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CacheStorageDeleteEntryReturns struct {
	
}

/* Deletes a cache entry. */
func (t *Tab) CacheStorageDeleteEntry(cacheId CacheStorageCacheId, request string) (CacheStorageDeleteEntryReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cacheId"] = cacheId
	
	
	
	params_["request"] = request
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CacheStorage.deleteEntry",
		"params": params_,
	})

	var returns_ CacheStorageDeleteEntryReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CacheStorageRequestCacheNamesReturns struct {
	
	Caches []CacheStorageCache
	
}

/* Requests cache names. */
func (t *Tab) CacheStorageRequestCacheNames(securityOrigin string) (CacheStorageRequestCacheNamesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CacheStorage.requestCacheNames",
		"params": params_,
	})

	var returns_ CacheStorageRequestCacheNamesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CacheStorageRequestCachedResponseReturns struct {
	
	Response CacheStorageCachedResponse
	
}

/* Fetches cache entry. */
func (t *Tab) CacheStorageRequestCachedResponse(cacheId CacheStorageCacheId, requestURL string, requestHeaders []CacheStorageHeader) (CacheStorageRequestCachedResponseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cacheId"] = cacheId
	
	
	
	params_["requestURL"] = requestURL
	
	
	
	params_["requestHeaders"] = requestHeaders
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CacheStorage.requestCachedResponse",
		"params": params_,
	})

	var returns_ CacheStorageRequestCachedResponseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CacheStorageRequestEntriesReturns struct {
	
	CacheDataEntries []CacheStorageDataEntry
	
	ReturnCount float64
	
}

/* Requests data from cache. */
func (t *Tab) CacheStorageRequestEntries(cacheId CacheStorageCacheId, skipCount int, pageSize int, pathFilter string) (CacheStorageRequestEntriesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cacheId"] = cacheId
	
	
	
	if !isZero(skipCount) {
		params_["skipCount"] = skipCount
	}
	
	
	
	if !isZero(pageSize) {
		params_["pageSize"] = pageSize
	}
	
	
	
	if !isZero(pathFilter) {
		params_["pathFilter"] = pathFilter
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "CacheStorage.requestEntries",
		"params": params_,
	})

	var returns_ CacheStorageRequestEntriesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CastEnableReturns struct {
	
}

/* Starts observing for sinks that can be used for tab mirroring, and if set,
sinks compatible with |presentationUrl| as well. When sinks are found, a
|sinksUpdated| event is fired.
Also starts observing for issue messages. When an issue is added or removed,
an |issueUpdated| event is fired. */
func (t *Tab) CastEnable(presentationUrl string) (CastEnableReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(presentationUrl) {
		params_["presentationUrl"] = presentationUrl
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Cast.enable",
		"params": params_,
	})

	var returns_ CastEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CastDisableReturns struct {
	
}

/* Stops observing for sinks and issues. */
func (t *Tab) CastDisable() (CastDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Cast.disable",
		"params": params_,
	})

	var returns_ CastDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CastSetSinkToUseReturns struct {
	
}

/* Sets a sink to be used when the web page requests the browser to choose a
sink via Presentation API, Remote Playback API, or Cast SDK. */
func (t *Tab) CastSetSinkToUse(sinkName string) (CastSetSinkToUseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["sinkName"] = sinkName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Cast.setSinkToUse",
		"params": params_,
	})

	var returns_ CastSetSinkToUseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CastStartTabMirroringReturns struct {
	
}

/* Starts mirroring the tab to the sink. */
func (t *Tab) CastStartTabMirroring(sinkName string) (CastStartTabMirroringReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["sinkName"] = sinkName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Cast.startTabMirroring",
		"params": params_,
	})

	var returns_ CastStartTabMirroringReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type CastStopCastingReturns struct {
	
}

/* Stops the active Cast session on the sink. */
func (t *Tab) CastStopCasting(sinkName string) (CastStopCastingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["sinkName"] = sinkName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Cast.stopCasting",
		"params": params_,
	})

	var returns_ CastStopCastingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMCollectClassNamesFromSubtreeReturns struct {
	
	ClassNames []string
	
}

/* Collects class names for the node with given id and all of it's child nodes. */
func (t *Tab) DOMCollectClassNamesFromSubtree(nodeId DOMNodeId) (DOMCollectClassNamesFromSubtreeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.collectClassNamesFromSubtree",
		"params": params_,
	})

	var returns_ DOMCollectClassNamesFromSubtreeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMCopyToReturns struct {
	
	NodeId DOMNodeId
	
}

/* Creates a deep copy of the specified node and places it into the target container before the
given anchor. */
func (t *Tab) DOMCopyTo(nodeId DOMNodeId, targetNodeId DOMNodeId, insertBeforeNodeId DOMNodeId) (DOMCopyToReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["targetNodeId"] = targetNodeId
	
	
	
	if !isZero(insertBeforeNodeId) {
		params_["insertBeforeNodeId"] = insertBeforeNodeId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.copyTo",
		"params": params_,
	})

	var returns_ DOMCopyToReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDescribeNodeReturns struct {
	
	Node DOMNode
	
}

/* Describes node given its id, does not require domain to be enabled. Does not start tracking any
objects, can be used for automation. */
func (t *Tab) DOMDescribeNode(nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId, depth int, pierce bool) (DOMDescribeNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	
	
	if !isZero(depth) {
		params_["depth"] = depth
	}
	
	
	
	if !isZero(pierce) {
		params_["pierce"] = pierce
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.describeNode",
		"params": params_,
	})

	var returns_ DOMDescribeNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDisableReturns struct {
	
}

/* Disables DOM agent for the given page. */
func (t *Tab) DOMDisable() (DOMDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.disable",
		"params": params_,
	})

	var returns_ DOMDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDiscardSearchResultsReturns struct {
	
}

/* Discards search results from the session with the given id. `getSearchResults` should no longer
be called for that search. */
func (t *Tab) DOMDiscardSearchResults(searchId string) (DOMDiscardSearchResultsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["searchId"] = searchId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.discardSearchResults",
		"params": params_,
	})

	var returns_ DOMDiscardSearchResultsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMEnableReturns struct {
	
}

/* Enables DOM agent for the given page. */
func (t *Tab) DOMEnable() (DOMEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.enable",
		"params": params_,
	})

	var returns_ DOMEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMFocusReturns struct {
	
}

/* Focuses the given element. */
func (t *Tab) DOMFocus(nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId) (DOMFocusReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.focus",
		"params": params_,
	})

	var returns_ DOMFocusReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetAttributesReturns struct {
	
	Attributes []string
	
}

/* Returns attributes for the specified node. */
func (t *Tab) DOMGetAttributes(nodeId DOMNodeId) (DOMGetAttributesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getAttributes",
		"params": params_,
	})

	var returns_ DOMGetAttributesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetBoxModelReturns struct {
	
	Model DOMBoxModel
	
}

/* Returns boxes for the given node. */
func (t *Tab) DOMGetBoxModel(nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId) (DOMGetBoxModelReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getBoxModel",
		"params": params_,
	})

	var returns_ DOMGetBoxModelReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetContentQuadsReturns struct {
	
	Quads []DOMQuad
	
}

/* Returns quads that describe node position on the page. This method
might return multiple quads for inline nodes. */
func (t *Tab) DOMGetContentQuads(nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId) (DOMGetContentQuadsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getContentQuads",
		"params": params_,
	})

	var returns_ DOMGetContentQuadsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetDocumentReturns struct {
	
	Root DOMNode
	
}

/* Returns the root DOM node (and optionally the subtree) to the caller. */
func (t *Tab) DOMGetDocument(depth int, pierce bool) (DOMGetDocumentReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(depth) {
		params_["depth"] = depth
	}
	
	
	
	if !isZero(pierce) {
		params_["pierce"] = pierce
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getDocument",
		"params": params_,
	})

	var returns_ DOMGetDocumentReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetFlattenedDocumentReturns struct {
	
	Nodes []DOMNode
	
}

/* Returns the root DOM node (and optionally the subtree) to the caller. */
func (t *Tab) DOMGetFlattenedDocument(depth int, pierce bool) (DOMGetFlattenedDocumentReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(depth) {
		params_["depth"] = depth
	}
	
	
	
	if !isZero(pierce) {
		params_["pierce"] = pierce
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getFlattenedDocument",
		"params": params_,
	})

	var returns_ DOMGetFlattenedDocumentReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetNodeForLocationReturns struct {
	
	BackendNodeId DOMBackendNodeId
	
	FrameId PageFrameId
	
	NodeId DOMNodeId
	
}

/* Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
either returned or not. */
func (t *Tab) DOMGetNodeForLocation(x int, y int, includeUserAgentShadowDOM bool, ignorePointerEventsNone bool) (DOMGetNodeForLocationReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["x"] = x
	
	
	
	params_["y"] = y
	
	
	
	if !isZero(includeUserAgentShadowDOM) {
		params_["includeUserAgentShadowDOM"] = includeUserAgentShadowDOM
	}
	
	
	
	if !isZero(ignorePointerEventsNone) {
		params_["ignorePointerEventsNone"] = ignorePointerEventsNone
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getNodeForLocation",
		"params": params_,
	})

	var returns_ DOMGetNodeForLocationReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetOuterHTMLReturns struct {
	
	OuterHTML string
	
}

/* Returns node's HTML markup. */
func (t *Tab) DOMGetOuterHTML(nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId) (DOMGetOuterHTMLReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getOuterHTML",
		"params": params_,
	})

	var returns_ DOMGetOuterHTMLReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetRelayoutBoundaryReturns struct {
	
	NodeId DOMNodeId
	
}

/* Returns the id of the nearest ancestor that is a relayout boundary. */
func (t *Tab) DOMGetRelayoutBoundary(nodeId DOMNodeId) (DOMGetRelayoutBoundaryReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getRelayoutBoundary",
		"params": params_,
	})

	var returns_ DOMGetRelayoutBoundaryReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetSearchResultsReturns struct {
	
	NodeIds []DOMNodeId
	
}

/* Returns search results from given `fromIndex` to given `toIndex` from the search with the given
identifier. */
func (t *Tab) DOMGetSearchResults(searchId string, fromIndex int, toIndex int) (DOMGetSearchResultsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["searchId"] = searchId
	
	
	
	params_["fromIndex"] = fromIndex
	
	
	
	params_["toIndex"] = toIndex
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getSearchResults",
		"params": params_,
	})

	var returns_ DOMGetSearchResultsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMHideHighlightReturns struct {
	
}

/* Hides any highlight. */
func (t *Tab) DOMHideHighlight() (DOMHideHighlightReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.hideHighlight",
		"params": params_,
	})

	var returns_ DOMHideHighlightReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMHighlightNodeReturns struct {
	
}

/* Highlights DOM node. */
func (t *Tab) DOMHighlightNode() (DOMHighlightNodeReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.highlightNode",
		"params": params_,
	})

	var returns_ DOMHighlightNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMHighlightRectReturns struct {
	
}

/* Highlights given rectangle. */
func (t *Tab) DOMHighlightRect() (DOMHighlightRectReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.highlightRect",
		"params": params_,
	})

	var returns_ DOMHighlightRectReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMMarkUndoableStateReturns struct {
	
}

/* Marks last undoable state. */
func (t *Tab) DOMMarkUndoableState() (DOMMarkUndoableStateReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.markUndoableState",
		"params": params_,
	})

	var returns_ DOMMarkUndoableStateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMMoveToReturns struct {
	
	NodeId DOMNodeId
	
}

/* Moves node into the new container, places it before the given anchor. */
func (t *Tab) DOMMoveTo(nodeId DOMNodeId, targetNodeId DOMNodeId, insertBeforeNodeId DOMNodeId) (DOMMoveToReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["targetNodeId"] = targetNodeId
	
	
	
	if !isZero(insertBeforeNodeId) {
		params_["insertBeforeNodeId"] = insertBeforeNodeId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.moveTo",
		"params": params_,
	})

	var returns_ DOMMoveToReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMPerformSearchReturns struct {
	
	SearchId string
	
	ResultCount int
	
}

/* Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
`cancelSearch` to end this search session. */
func (t *Tab) DOMPerformSearch(query string, includeUserAgentShadowDOM bool) (DOMPerformSearchReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["query"] = query
	
	
	
	if !isZero(includeUserAgentShadowDOM) {
		params_["includeUserAgentShadowDOM"] = includeUserAgentShadowDOM
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.performSearch",
		"params": params_,
	})

	var returns_ DOMPerformSearchReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMPushNodeByPathToFrontendReturns struct {
	
	NodeId DOMNodeId
	
}

/* Requests that the node is sent to the caller given its path. // FIXME, use XPath */
func (t *Tab) DOMPushNodeByPathToFrontend(path string) (DOMPushNodeByPathToFrontendReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["path"] = path
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.pushNodeByPathToFrontend",
		"params": params_,
	})

	var returns_ DOMPushNodeByPathToFrontendReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMPushNodesByBackendIdsToFrontendReturns struct {
	
	NodeIds []DOMNodeId
	
}

/* Requests that a batch of nodes is sent to the caller given their backend node ids. */
func (t *Tab) DOMPushNodesByBackendIdsToFrontend(backendNodeIds []DOMBackendNodeId) (DOMPushNodesByBackendIdsToFrontendReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["backendNodeIds"] = backendNodeIds
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.pushNodesByBackendIdsToFrontend",
		"params": params_,
	})

	var returns_ DOMPushNodesByBackendIdsToFrontendReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMQuerySelectorReturns struct {
	
	NodeId DOMNodeId
	
}

/* Executes `querySelector` on a given node. */
func (t *Tab) DOMQuerySelector(nodeId DOMNodeId, selector string) (DOMQuerySelectorReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["selector"] = selector
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.querySelector",
		"params": params_,
	})

	var returns_ DOMQuerySelectorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMQuerySelectorAllReturns struct {
	
	NodeIds []DOMNodeId
	
}

/* Executes `querySelectorAll` on a given node. */
func (t *Tab) DOMQuerySelectorAll(nodeId DOMNodeId, selector string) (DOMQuerySelectorAllReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["selector"] = selector
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.querySelectorAll",
		"params": params_,
	})

	var returns_ DOMQuerySelectorAllReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMRedoReturns struct {
	
}

/* Re-does the last undone action. */
func (t *Tab) DOMRedo() (DOMRedoReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.redo",
		"params": params_,
	})

	var returns_ DOMRedoReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMRemoveAttributeReturns struct {
	
}

/* Removes attribute with given name from an element with given id. */
func (t *Tab) DOMRemoveAttribute(nodeId DOMNodeId, name string) (DOMRemoveAttributeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["name"] = name
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.removeAttribute",
		"params": params_,
	})

	var returns_ DOMRemoveAttributeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMRemoveNodeReturns struct {
	
}

/* Removes node with given id. */
func (t *Tab) DOMRemoveNode(nodeId DOMNodeId) (DOMRemoveNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.removeNode",
		"params": params_,
	})

	var returns_ DOMRemoveNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMRequestChildNodesReturns struct {
	
}

/* Requests that children of the node with given id are returned to the caller in form of
`setChildNodes` events where not only immediate children are retrieved, but all children down to
the specified depth. */
func (t *Tab) DOMRequestChildNodes(nodeId DOMNodeId, depth int, pierce bool) (DOMRequestChildNodesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	if !isZero(depth) {
		params_["depth"] = depth
	}
	
	
	
	if !isZero(pierce) {
		params_["pierce"] = pierce
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.requestChildNodes",
		"params": params_,
	})

	var returns_ DOMRequestChildNodesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMRequestNodeReturns struct {
	
	NodeId DOMNodeId
	
}

/* Requests that the node is sent to the caller given the JavaScript node object reference. All
nodes that form the path from the node to the root are also sent to the client as a series of
`setChildNodes` notifications. */
func (t *Tab) DOMRequestNode(objectId RuntimeRemoteObjectId) (DOMRequestNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.requestNode",
		"params": params_,
	})

	var returns_ DOMRequestNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMResolveNodeReturns struct {
	
	Object RuntimeRemoteObject
	
}

/* Resolves the JavaScript node object for a given NodeId or BackendNodeId. */
func (t *Tab) DOMResolveNode(nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectGroup string, executionContextId RuntimeExecutionContextId) (DOMResolveNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectGroup) {
		params_["objectGroup"] = objectGroup
	}
	
	
	
	if !isZero(executionContextId) {
		params_["executionContextId"] = executionContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.resolveNode",
		"params": params_,
	})

	var returns_ DOMResolveNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetAttributeValueReturns struct {
	
}

/* Sets attribute for an element with given id. */
func (t *Tab) DOMSetAttributeValue(nodeId DOMNodeId, name string, value string) (DOMSetAttributeValueReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["name"] = name
	
	
	
	params_["value"] = value
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setAttributeValue",
		"params": params_,
	})

	var returns_ DOMSetAttributeValueReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetAttributesAsTextReturns struct {
	
}

/* Sets attributes on element with given id. This method is useful when user edits some existing
attribute value and types in several attribute name/value pairs. */
func (t *Tab) DOMSetAttributesAsText(nodeId DOMNodeId, text string, name string) (DOMSetAttributesAsTextReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["text"] = text
	
	
	
	if !isZero(name) {
		params_["name"] = name
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setAttributesAsText",
		"params": params_,
	})

	var returns_ DOMSetAttributesAsTextReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetFileInputFilesReturns struct {
	
}

/* Sets files for the given file input element. */
func (t *Tab) DOMSetFileInputFiles(files []string, nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId) (DOMSetFileInputFilesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["files"] = files
	
	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setFileInputFiles",
		"params": params_,
	})

	var returns_ DOMSetFileInputFilesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetNodeStackTracesEnabledReturns struct {
	
}

/* Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled. */
func (t *Tab) DOMSetNodeStackTracesEnabled(enable bool) (DOMSetNodeStackTracesEnabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enable"] = enable
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setNodeStackTracesEnabled",
		"params": params_,
	})

	var returns_ DOMSetNodeStackTracesEnabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetNodeStackTracesReturns struct {
	
	Creation RuntimeStackTrace
	
}

/* Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation. */
func (t *Tab) DOMGetNodeStackTraces(nodeId DOMNodeId) (DOMGetNodeStackTracesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getNodeStackTraces",
		"params": params_,
	})

	var returns_ DOMGetNodeStackTracesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetFileInfoReturns struct {
	
	Path string
	
}

/* Returns file information for the given
File wrapper. */
func (t *Tab) DOMGetFileInfo(objectId RuntimeRemoteObjectId) (DOMGetFileInfoReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getFileInfo",
		"params": params_,
	})

	var returns_ DOMGetFileInfoReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetInspectedNodeReturns struct {
	
}

/* Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions). */
func (t *Tab) DOMSetInspectedNode(nodeId DOMNodeId) (DOMSetInspectedNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setInspectedNode",
		"params": params_,
	})

	var returns_ DOMSetInspectedNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetNodeNameReturns struct {
	
	NodeId DOMNodeId
	
}

/* Sets node name for a node with given id. */
func (t *Tab) DOMSetNodeName(nodeId DOMNodeId, name string) (DOMSetNodeNameReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["name"] = name
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setNodeName",
		"params": params_,
	})

	var returns_ DOMSetNodeNameReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetNodeValueReturns struct {
	
}

/* Sets node value for a node with given id. */
func (t *Tab) DOMSetNodeValue(nodeId DOMNodeId, value string) (DOMSetNodeValueReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["value"] = value
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setNodeValue",
		"params": params_,
	})

	var returns_ DOMSetNodeValueReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSetOuterHTMLReturns struct {
	
}

/* Sets node HTML markup, returns new node id. */
func (t *Tab) DOMSetOuterHTML(nodeId DOMNodeId, outerHTML string) (DOMSetOuterHTMLReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["outerHTML"] = outerHTML
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.setOuterHTML",
		"params": params_,
	})

	var returns_ DOMSetOuterHTMLReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMUndoReturns struct {
	
}

/* Undoes the last performed action. */
func (t *Tab) DOMUndo() (DOMUndoReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.undo",
		"params": params_,
	})

	var returns_ DOMUndoReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMGetFrameOwnerReturns struct {
	
	BackendNodeId DOMBackendNodeId
	
	NodeId DOMNodeId
	
}

/* Returns iframe node that owns iframe with the given domain. */
func (t *Tab) DOMGetFrameOwner(frameId PageFrameId) (DOMGetFrameOwnerReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOM.getFrameOwner",
		"params": params_,
	})

	var returns_ DOMGetFrameOwnerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerGetEventListenersReturns struct {
	
	Listeners []DOMDebuggerEventListener
	
}

/* Returns event listeners of the given object. */
func (t *Tab) DOMDebuggerGetEventListeners(objectId RuntimeRemoteObjectId, depth int, pierce bool) (DOMDebuggerGetEventListenersReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	
	
	if !isZero(depth) {
		params_["depth"] = depth
	}
	
	
	
	if !isZero(pierce) {
		params_["pierce"] = pierce
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.getEventListeners",
		"params": params_,
	})

	var returns_ DOMDebuggerGetEventListenersReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerRemoveDOMBreakpointReturns struct {
	
}

/* Removes DOM breakpoint that was set using `setDOMBreakpoint`. */
func (t *Tab) DOMDebuggerRemoveDOMBreakpoint(nodeId DOMNodeId, Type DOMDebuggerDOMBreakpointType) (DOMDebuggerRemoveDOMBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["Type"] = Type
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.removeDOMBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerRemoveDOMBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerRemoveEventListenerBreakpointReturns struct {
	
}

/* Removes breakpoint on particular DOM event. */
func (t *Tab) DOMDebuggerRemoveEventListenerBreakpoint(eventName string, targetName string) (DOMDebuggerRemoveEventListenerBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["eventName"] = eventName
	
	
	
	if !isZero(targetName) {
		params_["targetName"] = targetName
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.removeEventListenerBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerRemoveEventListenerBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerRemoveInstrumentationBreakpointReturns struct {
	
}

/* Removes breakpoint on particular native event. */
func (t *Tab) DOMDebuggerRemoveInstrumentationBreakpoint(eventName string) (DOMDebuggerRemoveInstrumentationBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["eventName"] = eventName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.removeInstrumentationBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerRemoveInstrumentationBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerRemoveXHRBreakpointReturns struct {
	
}

/* Removes breakpoint from XMLHttpRequest. */
func (t *Tab) DOMDebuggerRemoveXHRBreakpoint(url string) (DOMDebuggerRemoveXHRBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["url"] = url
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.removeXHRBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerRemoveXHRBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerSetDOMBreakpointReturns struct {
	
}

/* Sets breakpoint on particular operation with DOM. */
func (t *Tab) DOMDebuggerSetDOMBreakpoint(nodeId DOMNodeId, Type DOMDebuggerDOMBreakpointType) (DOMDebuggerSetDOMBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	params_["Type"] = Type
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.setDOMBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerSetDOMBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerSetEventListenerBreakpointReturns struct {
	
}

/* Sets breakpoint on particular DOM event. */
func (t *Tab) DOMDebuggerSetEventListenerBreakpoint(eventName string, targetName string) (DOMDebuggerSetEventListenerBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["eventName"] = eventName
	
	
	
	if !isZero(targetName) {
		params_["targetName"] = targetName
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.setEventListenerBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerSetEventListenerBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerSetInstrumentationBreakpointReturns struct {
	
}

/* Sets breakpoint on particular native event. */
func (t *Tab) DOMDebuggerSetInstrumentationBreakpoint(eventName string) (DOMDebuggerSetInstrumentationBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["eventName"] = eventName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.setInstrumentationBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerSetInstrumentationBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMDebuggerSetXHRBreakpointReturns struct {
	
}

/* Sets breakpoint on XMLHttpRequest. */
func (t *Tab) DOMDebuggerSetXHRBreakpoint(url string) (DOMDebuggerSetXHRBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["url"] = url
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMDebugger.setXHRBreakpoint",
		"params": params_,
	})

	var returns_ DOMDebuggerSetXHRBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSnapshotDisableReturns struct {
	
}

/* Disables DOM snapshot agent for the given page. */
func (t *Tab) DOMSnapshotDisable() (DOMSnapshotDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMSnapshot.disable",
		"params": params_,
	})

	var returns_ DOMSnapshotDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSnapshotEnableReturns struct {
	
}

/* Enables DOM snapshot agent for the given page. */
func (t *Tab) DOMSnapshotEnable() (DOMSnapshotEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMSnapshot.enable",
		"params": params_,
	})

	var returns_ DOMSnapshotEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSnapshotGetSnapshotReturns struct {
	
	DomNodes []DOMSnapshotDOMNode
	
	LayoutTreeNodes []DOMSnapshotLayoutTreeNode
	
	ComputedStyles []DOMSnapshotComputedStyle
	
}

/* Returns a document snapshot, including the full DOM tree of the root node (including iframes,
template contents, and imported documents) in a flattened array, as well as layout and
white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
flattened. */
func (t *Tab) DOMSnapshotGetSnapshot(computedStyleWhitelist []string, includeEventListeners bool, includePaintOrder bool, includeUserAgentShadowTree bool) (DOMSnapshotGetSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["computedStyleWhitelist"] = computedStyleWhitelist
	
	
	
	if !isZero(includeEventListeners) {
		params_["includeEventListeners"] = includeEventListeners
	}
	
	
	
	if !isZero(includePaintOrder) {
		params_["includePaintOrder"] = includePaintOrder
	}
	
	
	
	if !isZero(includeUserAgentShadowTree) {
		params_["includeUserAgentShadowTree"] = includeUserAgentShadowTree
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMSnapshot.getSnapshot",
		"params": params_,
	})

	var returns_ DOMSnapshotGetSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMSnapshotCaptureSnapshotReturns struct {
	
	Documents []DOMSnapshotDocumentSnapshot
	
	Strings []string
	
}

/* Returns a document snapshot, including the full DOM tree of the root node (including iframes,
template contents, and imported documents) in a flattened array, as well as layout and
white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
flattened. */
func (t *Tab) DOMSnapshotCaptureSnapshot(computedStyles []string, includePaintOrder bool, includeDOMRects bool) (DOMSnapshotCaptureSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["computedStyles"] = computedStyles
	
	
	
	if !isZero(includePaintOrder) {
		params_["includePaintOrder"] = includePaintOrder
	}
	
	
	
	if !isZero(includeDOMRects) {
		params_["includeDOMRects"] = includeDOMRects
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMSnapshot.captureSnapshot",
		"params": params_,
	})

	var returns_ DOMSnapshotCaptureSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMStorageClearReturns struct {
	
}

/*  */
func (t *Tab) DOMStorageClear(storageId DOMStorageStorageId) (DOMStorageClearReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["storageId"] = storageId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMStorage.clear",
		"params": params_,
	})

	var returns_ DOMStorageClearReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMStorageDisableReturns struct {
	
}

/* Disables storage tracking, prevents storage events from being sent to the client. */
func (t *Tab) DOMStorageDisable() (DOMStorageDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMStorage.disable",
		"params": params_,
	})

	var returns_ DOMStorageDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMStorageEnableReturns struct {
	
}

/* Enables storage tracking, storage events will now be delivered to the client. */
func (t *Tab) DOMStorageEnable() (DOMStorageEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMStorage.enable",
		"params": params_,
	})

	var returns_ DOMStorageEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMStorageGetDOMStorageItemsReturns struct {
	
	Entries []DOMStorageItem
	
}

/*  */
func (t *Tab) DOMStorageGetDOMStorageItems(storageId DOMStorageStorageId) (DOMStorageGetDOMStorageItemsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["storageId"] = storageId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMStorage.getDOMStorageItems",
		"params": params_,
	})

	var returns_ DOMStorageGetDOMStorageItemsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMStorageRemoveDOMStorageItemReturns struct {
	
}

/*  */
func (t *Tab) DOMStorageRemoveDOMStorageItem(storageId DOMStorageStorageId, key string) (DOMStorageRemoveDOMStorageItemReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["storageId"] = storageId
	
	
	
	params_["key"] = key
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMStorage.removeDOMStorageItem",
		"params": params_,
	})

	var returns_ DOMStorageRemoveDOMStorageItemReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DOMStorageSetDOMStorageItemReturns struct {
	
}

/*  */
func (t *Tab) DOMStorageSetDOMStorageItem(storageId DOMStorageStorageId, key string, value string) (DOMStorageSetDOMStorageItemReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["storageId"] = storageId
	
	
	
	params_["key"] = key
	
	
	
	params_["value"] = value
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DOMStorage.setDOMStorageItem",
		"params": params_,
	})

	var returns_ DOMStorageSetDOMStorageItemReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DatabaseDisableReturns struct {
	
}

/* Disables database tracking, prevents database events from being sent to the client. */
func (t *Tab) DatabaseDisable() (DatabaseDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Database.disable",
		"params": params_,
	})

	var returns_ DatabaseDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DatabaseEnableReturns struct {
	
}

/* Enables database tracking, database events will now be delivered to the client. */
func (t *Tab) DatabaseEnable() (DatabaseEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Database.enable",
		"params": params_,
	})

	var returns_ DatabaseEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DatabaseExecuteSQLReturns struct {
	
	ColumnNames []string
	
	Values []interface{}
	
	SqlError DatabaseError
	
}

/*  */
func (t *Tab) DatabaseExecuteSQL(databaseId DatabaseDatabaseId, query string) (DatabaseExecuteSQLReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["databaseId"] = databaseId
	
	
	
	params_["query"] = query
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Database.executeSQL",
		"params": params_,
	})

	var returns_ DatabaseExecuteSQLReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DatabaseGetDatabaseTableNamesReturns struct {
	
	TableNames []string
	
}

/*  */
func (t *Tab) DatabaseGetDatabaseTableNames(databaseId DatabaseDatabaseId) (DatabaseGetDatabaseTableNamesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["databaseId"] = databaseId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Database.getDatabaseTableNames",
		"params": params_,
	})

	var returns_ DatabaseGetDatabaseTableNamesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DeviceOrientationClearDeviceOrientationOverrideReturns struct {
	
}

/* Clears the overridden Device Orientation. */
func (t *Tab) DeviceOrientationClearDeviceOrientationOverride() (DeviceOrientationClearDeviceOrientationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DeviceOrientation.clearDeviceOrientationOverride",
		"params": params_,
	})

	var returns_ DeviceOrientationClearDeviceOrientationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DeviceOrientationSetDeviceOrientationOverrideReturns struct {
	
}

/* Overrides the Device Orientation. */
func (t *Tab) DeviceOrientationSetDeviceOrientationOverride(alpha float64, beta float64, gamma float64) (DeviceOrientationSetDeviceOrientationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["alpha"] = alpha
	
	
	
	params_["beta"] = beta
	
	
	
	params_["gamma"] = gamma
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "DeviceOrientation.setDeviceOrientationOverride",
		"params": params_,
	})

	var returns_ DeviceOrientationSetDeviceOrientationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationCanEmulateReturns struct {
	
	Result bool
	
}

/* Tells whether emulation is supported. */
func (t *Tab) EmulationCanEmulate() (EmulationCanEmulateReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.canEmulate",
		"params": params_,
	})

	var returns_ EmulationCanEmulateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationClearDeviceMetricsOverrideReturns struct {
	
}

/* Clears the overriden device metrics. */
func (t *Tab) EmulationClearDeviceMetricsOverride() (EmulationClearDeviceMetricsOverrideReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.clearDeviceMetricsOverride",
		"params": params_,
	})

	var returns_ EmulationClearDeviceMetricsOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationClearGeolocationOverrideReturns struct {
	
}

/* Clears the overriden Geolocation Position and Error. */
func (t *Tab) EmulationClearGeolocationOverride() (EmulationClearGeolocationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.clearGeolocationOverride",
		"params": params_,
	})

	var returns_ EmulationClearGeolocationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationResetPageScaleFactorReturns struct {
	
}

/* Requests that page scale factor is reset to initial values. */
func (t *Tab) EmulationResetPageScaleFactor() (EmulationResetPageScaleFactorReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.resetPageScaleFactor",
		"params": params_,
	})

	var returns_ EmulationResetPageScaleFactorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetFocusEmulationEnabledReturns struct {
	
}

/* Enables or disables simulating a focused and active page. */
func (t *Tab) EmulationSetFocusEmulationEnabled(enabled bool) (EmulationSetFocusEmulationEnabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setFocusEmulationEnabled",
		"params": params_,
	})

	var returns_ EmulationSetFocusEmulationEnabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetCPUThrottlingRateReturns struct {
	
}

/* Enables CPU throttling to emulate slow CPUs. */
func (t *Tab) EmulationSetCPUThrottlingRate(rate float64) (EmulationSetCPUThrottlingRateReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["rate"] = rate
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setCPUThrottlingRate",
		"params": params_,
	})

	var returns_ EmulationSetCPUThrottlingRateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetDefaultBackgroundColorOverrideReturns struct {
	
}

/* Sets or clears an override of the default background color of the frame. This override is used
if the content does not specify one. */
func (t *Tab) EmulationSetDefaultBackgroundColorOverride(color DOMRGBA) (EmulationSetDefaultBackgroundColorOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(color) {
		params_["color"] = color
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setDefaultBackgroundColorOverride",
		"params": params_,
	})

	var returns_ EmulationSetDefaultBackgroundColorOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetDeviceMetricsOverrideReturns struct {
	
}

/* Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
query results). */
func (t *Tab) EmulationSetDeviceMetricsOverride(width int, height int, deviceScaleFactor float64, mobile bool, scale float64, screenWidth int, screenHeight int, positionX int, positionY int, dontSetVisibleSize bool, screenOrientation EmulationScreenOrientation, viewport PageViewport) (EmulationSetDeviceMetricsOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["width"] = width
	
	
	
	params_["height"] = height
	
	
	
	params_["deviceScaleFactor"] = deviceScaleFactor
	
	
	
	params_["mobile"] = mobile
	
	
	
	if !isZero(scale) {
		params_["scale"] = scale
	}
	
	
	
	if !isZero(screenWidth) {
		params_["screenWidth"] = screenWidth
	}
	
	
	
	if !isZero(screenHeight) {
		params_["screenHeight"] = screenHeight
	}
	
	
	
	if !isZero(positionX) {
		params_["positionX"] = positionX
	}
	
	
	
	if !isZero(positionY) {
		params_["positionY"] = positionY
	}
	
	
	
	if !isZero(dontSetVisibleSize) {
		params_["dontSetVisibleSize"] = dontSetVisibleSize
	}
	
	
	
	if !isZero(screenOrientation) {
		params_["screenOrientation"] = screenOrientation
	}
	
	
	
	if !isZero(viewport) {
		params_["viewport"] = viewport
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setDeviceMetricsOverride",
		"params": params_,
	})

	var returns_ EmulationSetDeviceMetricsOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetScrollbarsHiddenReturns struct {
	
}

/*  */
func (t *Tab) EmulationSetScrollbarsHidden(hidden bool) (EmulationSetScrollbarsHiddenReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["hidden"] = hidden
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setScrollbarsHidden",
		"params": params_,
	})

	var returns_ EmulationSetScrollbarsHiddenReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetDocumentCookieDisabledReturns struct {
	
}

/*  */
func (t *Tab) EmulationSetDocumentCookieDisabled(disabled bool) (EmulationSetDocumentCookieDisabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["disabled"] = disabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setDocumentCookieDisabled",
		"params": params_,
	})

	var returns_ EmulationSetDocumentCookieDisabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetEmitTouchEventsForMouseReturns struct {
	
}

/*  */
func (t *Tab) EmulationSetEmitTouchEventsForMouse(enabled bool, configuration string) (EmulationSetEmitTouchEventsForMouseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	
	
	if !isZero(configuration) {
		params_["configuration"] = configuration
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setEmitTouchEventsForMouse",
		"params": params_,
	})

	var returns_ EmulationSetEmitTouchEventsForMouseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetEmulatedMediaReturns struct {
	
}

/* Emulates the given media type or media feature for CSS media queries. */
func (t *Tab) EmulationSetEmulatedMedia(media string, features []EmulationMediaFeature) (EmulationSetEmulatedMediaReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(media) {
		params_["media"] = media
	}
	
	
	
	if !isZero(features) {
		params_["features"] = features
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setEmulatedMedia",
		"params": params_,
	})

	var returns_ EmulationSetEmulatedMediaReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetGeolocationOverrideReturns struct {
	
}

/* Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
unavailable. */
func (t *Tab) EmulationSetGeolocationOverride(latitude float64, longitude float64, accuracy float64) (EmulationSetGeolocationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(latitude) {
		params_["latitude"] = latitude
	}
	
	
	
	if !isZero(longitude) {
		params_["longitude"] = longitude
	}
	
	
	
	if !isZero(accuracy) {
		params_["accuracy"] = accuracy
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setGeolocationOverride",
		"params": params_,
	})

	var returns_ EmulationSetGeolocationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetNavigatorOverridesReturns struct {
	
}

/* Overrides value returned by the javascript navigator object. */
func (t *Tab) EmulationSetNavigatorOverrides(platform string) (EmulationSetNavigatorOverridesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["platform"] = platform
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setNavigatorOverrides",
		"params": params_,
	})

	var returns_ EmulationSetNavigatorOverridesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetPageScaleFactorReturns struct {
	
}

/* Sets a specified page scale factor. */
func (t *Tab) EmulationSetPageScaleFactor(pageScaleFactor float64) (EmulationSetPageScaleFactorReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["pageScaleFactor"] = pageScaleFactor
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setPageScaleFactor",
		"params": params_,
	})

	var returns_ EmulationSetPageScaleFactorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetScriptExecutionDisabledReturns struct {
	
}

/* Switches script execution in the page. */
func (t *Tab) EmulationSetScriptExecutionDisabled(value bool) (EmulationSetScriptExecutionDisabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["value"] = value
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setScriptExecutionDisabled",
		"params": params_,
	})

	var returns_ EmulationSetScriptExecutionDisabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetTouchEmulationEnabledReturns struct {
	
}

/* Enables touch on platforms which do not support them. */
func (t *Tab) EmulationSetTouchEmulationEnabled(enabled bool, maxTouchPoints int) (EmulationSetTouchEmulationEnabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	
	
	if !isZero(maxTouchPoints) {
		params_["maxTouchPoints"] = maxTouchPoints
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setTouchEmulationEnabled",
		"params": params_,
	})

	var returns_ EmulationSetTouchEmulationEnabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetVirtualTimePolicyReturns struct {
	
	VirtualTimeTicksBase float64
	
}

/* Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
the current virtual time policy.  Note this supersedes any previous time budget. */
func (t *Tab) EmulationSetVirtualTimePolicy(policy EmulationVirtualTimePolicy, budget float64, maxVirtualTimeTaskStarvationCount int, waitForNavigation bool, initialVirtualTime NetworkTimeSinceEpoch) (EmulationSetVirtualTimePolicyReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["policy"] = policy
	
	
	
	if !isZero(budget) {
		params_["budget"] = budget
	}
	
	
	
	if !isZero(maxVirtualTimeTaskStarvationCount) {
		params_["maxVirtualTimeTaskStarvationCount"] = maxVirtualTimeTaskStarvationCount
	}
	
	
	
	if !isZero(waitForNavigation) {
		params_["waitForNavigation"] = waitForNavigation
	}
	
	
	
	if !isZero(initialVirtualTime) {
		params_["initialVirtualTime"] = initialVirtualTime
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setVirtualTimePolicy",
		"params": params_,
	})

	var returns_ EmulationSetVirtualTimePolicyReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetTimezoneOverrideReturns struct {
	
}

/* Overrides default host system timezone with the specified one. */
func (t *Tab) EmulationSetTimezoneOverride(timezoneId string) (EmulationSetTimezoneOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["timezoneId"] = timezoneId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setTimezoneOverride",
		"params": params_,
	})

	var returns_ EmulationSetTimezoneOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetVisibleSizeReturns struct {
	
}

/* Resizes the frame/viewport of the page. Note that this does not affect the frame's container
(e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
on Android. */
func (t *Tab) EmulationSetVisibleSize(width int, height int) (EmulationSetVisibleSizeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["width"] = width
	
	
	
	params_["height"] = height
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setVisibleSize",
		"params": params_,
	})

	var returns_ EmulationSetVisibleSizeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type EmulationSetUserAgentOverrideReturns struct {
	
}

/* Allows overriding user agent with the given string. */
func (t *Tab) EmulationSetUserAgentOverride(userAgent string, acceptLanguage string, platform string) (EmulationSetUserAgentOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["userAgent"] = userAgent
	
	
	
	if !isZero(acceptLanguage) {
		params_["acceptLanguage"] = acceptLanguage
	}
	
	
	
	if !isZero(platform) {
		params_["platform"] = platform
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Emulation.setUserAgentOverride",
		"params": params_,
	})

	var returns_ EmulationSetUserAgentOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeadlessExperimentalBeginFrameReturns struct {
	
	HasDamage bool
	
	ScreenshotData []byte
	
}

/* Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
screenshot from the resulting frame. Requires that the target was created with enabled
BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
https://goo.gl/3zHXhB for more background. */
func (t *Tab) HeadlessExperimentalBeginFrame(frameTimeTicks float64, interval float64, noDisplayUpdates bool, screenshot HeadlessExperimentalScreenshotParams) (HeadlessExperimentalBeginFrameReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(frameTimeTicks) {
		params_["frameTimeTicks"] = frameTimeTicks
	}
	
	
	
	if !isZero(interval) {
		params_["interval"] = interval
	}
	
	
	
	if !isZero(noDisplayUpdates) {
		params_["noDisplayUpdates"] = noDisplayUpdates
	}
	
	
	
	if !isZero(screenshot) {
		params_["screenshot"] = screenshot
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeadlessExperimental.beginFrame",
		"params": params_,
	})

	var returns_ HeadlessExperimentalBeginFrameReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeadlessExperimentalDisableReturns struct {
	
}

/* Disables headless events for the target. */
func (t *Tab) HeadlessExperimentalDisable() (HeadlessExperimentalDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeadlessExperimental.disable",
		"params": params_,
	})

	var returns_ HeadlessExperimentalDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeadlessExperimentalEnableReturns struct {
	
}

/* Enables headless events for the target. */
func (t *Tab) HeadlessExperimentalEnable() (HeadlessExperimentalEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeadlessExperimental.enable",
		"params": params_,
	})

	var returns_ HeadlessExperimentalEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IOCloseReturns struct {
	
}

/* Close the stream, discard any temporary backing storage. */
func (t *Tab) IOClose(handle IOStreamHandle) (IOCloseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["handle"] = handle
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IO.close",
		"params": params_,
	})

	var returns_ IOCloseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IOReadReturns struct {
	
	Base64Encoded bool
	
	Data string
	
	Eof bool
	
}

/* Read a chunk of the stream */
func (t *Tab) IORead(handle IOStreamHandle, offset int, size int) (IOReadReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["handle"] = handle
	
	
	
	if !isZero(offset) {
		params_["offset"] = offset
	}
	
	
	
	if !isZero(size) {
		params_["size"] = size
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IO.read",
		"params": params_,
	})

	var returns_ IOReadReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IOResolveBlobReturns struct {
	
	Uuid string
	
}

/* Return UUID of Blob object specified by a remote object id. */
func (t *Tab) IOResolveBlob(objectId RuntimeRemoteObjectId) (IOResolveBlobReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IO.resolveBlob",
		"params": params_,
	})

	var returns_ IOResolveBlobReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBClearObjectStoreReturns struct {
	
}

/* Clears all entries from an object store. */
func (t *Tab) IndexedDBClearObjectStore(securityOrigin string, databaseName string, objectStoreName string) (IndexedDBClearObjectStoreReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	
	
	params_["databaseName"] = databaseName
	
	
	
	params_["objectStoreName"] = objectStoreName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.clearObjectStore",
		"params": params_,
	})

	var returns_ IndexedDBClearObjectStoreReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBDeleteDatabaseReturns struct {
	
}

/* Deletes a database. */
func (t *Tab) IndexedDBDeleteDatabase(securityOrigin string, databaseName string) (IndexedDBDeleteDatabaseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	
	
	params_["databaseName"] = databaseName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.deleteDatabase",
		"params": params_,
	})

	var returns_ IndexedDBDeleteDatabaseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBDeleteObjectStoreEntriesReturns struct {
	
}

/* Delete a range of entries from an object store */
func (t *Tab) IndexedDBDeleteObjectStoreEntries(securityOrigin string, databaseName string, objectStoreName string, keyRange IndexedDBKeyRange) (IndexedDBDeleteObjectStoreEntriesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	
	
	params_["databaseName"] = databaseName
	
	
	
	params_["objectStoreName"] = objectStoreName
	
	
	
	params_["keyRange"] = keyRange
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.deleteObjectStoreEntries",
		"params": params_,
	})

	var returns_ IndexedDBDeleteObjectStoreEntriesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBDisableReturns struct {
	
}

/* Disables events from backend. */
func (t *Tab) IndexedDBDisable() (IndexedDBDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.disable",
		"params": params_,
	})

	var returns_ IndexedDBDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBEnableReturns struct {
	
}

/* Enables events from backend. */
func (t *Tab) IndexedDBEnable() (IndexedDBEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.enable",
		"params": params_,
	})

	var returns_ IndexedDBEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBRequestDataReturns struct {
	
	ObjectStoreDataEntries []IndexedDBDataEntry
	
	HasMore bool
	
}

/* Requests data from object store or index. */
func (t *Tab) IndexedDBRequestData(securityOrigin string, databaseName string, objectStoreName string, indexName string, skipCount int, pageSize int, keyRange IndexedDBKeyRange) (IndexedDBRequestDataReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	
	
	params_["databaseName"] = databaseName
	
	
	
	params_["objectStoreName"] = objectStoreName
	
	
	
	params_["indexName"] = indexName
	
	
	
	params_["skipCount"] = skipCount
	
	
	
	params_["pageSize"] = pageSize
	
	
	
	if !isZero(keyRange) {
		params_["keyRange"] = keyRange
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.requestData",
		"params": params_,
	})

	var returns_ IndexedDBRequestDataReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBGetMetadataReturns struct {
	
	EntriesCount float64
	
	KeyGeneratorValue float64
	
}

/* Gets metadata of an object store */
func (t *Tab) IndexedDBGetMetadata(securityOrigin string, databaseName string, objectStoreName string) (IndexedDBGetMetadataReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	
	
	params_["databaseName"] = databaseName
	
	
	
	params_["objectStoreName"] = objectStoreName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.getMetadata",
		"params": params_,
	})

	var returns_ IndexedDBGetMetadataReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBRequestDatabaseReturns struct {
	
	DatabaseWithObjectStores IndexedDBDatabaseWithObjectStores
	
}

/* Requests database with given name in given frame. */
func (t *Tab) IndexedDBRequestDatabase(securityOrigin string, databaseName string) (IndexedDBRequestDatabaseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	
	
	params_["databaseName"] = databaseName
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.requestDatabase",
		"params": params_,
	})

	var returns_ IndexedDBRequestDatabaseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type IndexedDBRequestDatabaseNamesReturns struct {
	
	DatabaseNames []string
	
}

/* Requests database names for given security origin. */
func (t *Tab) IndexedDBRequestDatabaseNames(securityOrigin string) (IndexedDBRequestDatabaseNamesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["securityOrigin"] = securityOrigin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "IndexedDB.requestDatabaseNames",
		"params": params_,
	})

	var returns_ IndexedDBRequestDatabaseNamesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputDispatchKeyEventReturns struct {
	
}

/* Dispatches a key event to the page. */
func (t *Tab) InputDispatchKeyEvent(Type string, modifiers int, timestamp InputTimeSinceEpoch, text string, unmodifiedText string, keyIdentifier string, code string, key string, windowsVirtualKeyCode int, nativeVirtualKeyCode int, autoRepeat bool, isKeypad bool, isSystemKey bool, location int) (InputDispatchKeyEventReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["Type"] = Type
	
	
	
	if !isZero(modifiers) {
		params_["modifiers"] = modifiers
	}
	
	
	
	if !isZero(timestamp) {
		params_["timestamp"] = timestamp
	}
	
	
	
	if !isZero(text) {
		params_["text"] = text
	}
	
	
	
	if !isZero(unmodifiedText) {
		params_["unmodifiedText"] = unmodifiedText
	}
	
	
	
	if !isZero(keyIdentifier) {
		params_["keyIdentifier"] = keyIdentifier
	}
	
	
	
	if !isZero(code) {
		params_["code"] = code
	}
	
	
	
	if !isZero(key) {
		params_["key"] = key
	}
	
	
	
	if !isZero(windowsVirtualKeyCode) {
		params_["windowsVirtualKeyCode"] = windowsVirtualKeyCode
	}
	
	
	
	if !isZero(nativeVirtualKeyCode) {
		params_["nativeVirtualKeyCode"] = nativeVirtualKeyCode
	}
	
	
	
	if !isZero(autoRepeat) {
		params_["autoRepeat"] = autoRepeat
	}
	
	
	
	if !isZero(isKeypad) {
		params_["isKeypad"] = isKeypad
	}
	
	
	
	if !isZero(isSystemKey) {
		params_["isSystemKey"] = isSystemKey
	}
	
	
	
	if !isZero(location) {
		params_["location"] = location
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.dispatchKeyEvent",
		"params": params_,
	})

	var returns_ InputDispatchKeyEventReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputInsertTextReturns struct {
	
}

/* This method emulates inserting text that doesn't come from a key press,
for example an emoji keyboard or an IME. */
func (t *Tab) InputInsertText(text string) (InputInsertTextReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["text"] = text
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.insertText",
		"params": params_,
	})

	var returns_ InputInsertTextReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputDispatchMouseEventReturns struct {
	
}

/* Dispatches a mouse event to the page. */
func (t *Tab) InputDispatchMouseEvent(Type string, x float64, y float64, modifiers int, timestamp InputTimeSinceEpoch, button string, buttons int, clickCount int, deltaX float64, deltaY float64, pointerType string) (InputDispatchMouseEventReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["Type"] = Type
	
	
	
	params_["x"] = x
	
	
	
	params_["y"] = y
	
	
	
	if !isZero(modifiers) {
		params_["modifiers"] = modifiers
	}
	
	
	
	if !isZero(timestamp) {
		params_["timestamp"] = timestamp
	}
	
	
	
	if !isZero(button) {
		params_["button"] = button
	}
	
	
	
	if !isZero(buttons) {
		params_["buttons"] = buttons
	}
	
	
	
	if !isZero(clickCount) {
		params_["clickCount"] = clickCount
	}
	
	
	
	if !isZero(deltaX) {
		params_["deltaX"] = deltaX
	}
	
	
	
	if !isZero(deltaY) {
		params_["deltaY"] = deltaY
	}
	
	
	
	if !isZero(pointerType) {
		params_["pointerType"] = pointerType
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.dispatchMouseEvent",
		"params": params_,
	})

	var returns_ InputDispatchMouseEventReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputDispatchTouchEventReturns struct {
	
}

/* Dispatches a touch event to the page. */
func (t *Tab) InputDispatchTouchEvent(Type string, touchPoints []InputTouchPoint, modifiers int, timestamp InputTimeSinceEpoch) (InputDispatchTouchEventReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["Type"] = Type
	
	
	
	params_["touchPoints"] = touchPoints
	
	
	
	if !isZero(modifiers) {
		params_["modifiers"] = modifiers
	}
	
	
	
	if !isZero(timestamp) {
		params_["timestamp"] = timestamp
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.dispatchTouchEvent",
		"params": params_,
	})

	var returns_ InputDispatchTouchEventReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputEmulateTouchFromMouseEventReturns struct {
	
}

/* Emulates touch event from the mouse event parameters. */
func (t *Tab) InputEmulateTouchFromMouseEvent(Type string, x int, y int, button string, timestamp InputTimeSinceEpoch, deltaX float64, deltaY float64, modifiers int, clickCount int) (InputEmulateTouchFromMouseEventReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["Type"] = Type
	
	
	
	params_["x"] = x
	
	
	
	params_["y"] = y
	
	
	
	params_["button"] = button
	
	
	
	if !isZero(timestamp) {
		params_["timestamp"] = timestamp
	}
	
	
	
	if !isZero(deltaX) {
		params_["deltaX"] = deltaX
	}
	
	
	
	if !isZero(deltaY) {
		params_["deltaY"] = deltaY
	}
	
	
	
	if !isZero(modifiers) {
		params_["modifiers"] = modifiers
	}
	
	
	
	if !isZero(clickCount) {
		params_["clickCount"] = clickCount
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.emulateTouchFromMouseEvent",
		"params": params_,
	})

	var returns_ InputEmulateTouchFromMouseEventReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputSetIgnoreInputEventsReturns struct {
	
}

/* Ignores input events (useful while auditing page). */
func (t *Tab) InputSetIgnoreInputEvents(ignore bool) (InputSetIgnoreInputEventsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["ignore"] = ignore
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.setIgnoreInputEvents",
		"params": params_,
	})

	var returns_ InputSetIgnoreInputEventsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputSynthesizePinchGestureReturns struct {
	
}

/* Synthesizes a pinch gesture over a time period by issuing appropriate touch events. */
func (t *Tab) InputSynthesizePinchGesture(x float64, y float64, scaleFactor float64, relativeSpeed int, gestureSourceType InputGestureSourceType) (InputSynthesizePinchGestureReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["x"] = x
	
	
	
	params_["y"] = y
	
	
	
	params_["scaleFactor"] = scaleFactor
	
	
	
	if !isZero(relativeSpeed) {
		params_["relativeSpeed"] = relativeSpeed
	}
	
	
	
	if !isZero(gestureSourceType) {
		params_["gestureSourceType"] = gestureSourceType
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.synthesizePinchGesture",
		"params": params_,
	})

	var returns_ InputSynthesizePinchGestureReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputSynthesizeScrollGestureReturns struct {
	
}

/* Synthesizes a scroll gesture over a time period by issuing appropriate touch events. */
func (t *Tab) InputSynthesizeScrollGesture(x float64, y float64, xDistance float64, yDistance float64, xOverscroll float64, yOverscroll float64, preventFling bool, speed int, gestureSourceType InputGestureSourceType, repeatCount int, repeatDelayMs int, interactionMarkerName string) (InputSynthesizeScrollGestureReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["x"] = x
	
	
	
	params_["y"] = y
	
	
	
	if !isZero(xDistance) {
		params_["xDistance"] = xDistance
	}
	
	
	
	if !isZero(yDistance) {
		params_["yDistance"] = yDistance
	}
	
	
	
	if !isZero(xOverscroll) {
		params_["xOverscroll"] = xOverscroll
	}
	
	
	
	if !isZero(yOverscroll) {
		params_["yOverscroll"] = yOverscroll
	}
	
	
	
	if !isZero(preventFling) {
		params_["preventFling"] = preventFling
	}
	
	
	
	if !isZero(speed) {
		params_["speed"] = speed
	}
	
	
	
	if !isZero(gestureSourceType) {
		params_["gestureSourceType"] = gestureSourceType
	}
	
	
	
	if !isZero(repeatCount) {
		params_["repeatCount"] = repeatCount
	}
	
	
	
	if !isZero(repeatDelayMs) {
		params_["repeatDelayMs"] = repeatDelayMs
	}
	
	
	
	if !isZero(interactionMarkerName) {
		params_["interactionMarkerName"] = interactionMarkerName
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.synthesizeScrollGesture",
		"params": params_,
	})

	var returns_ InputSynthesizeScrollGestureReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InputSynthesizeTapGestureReturns struct {
	
}

/* Synthesizes a tap gesture over a time period by issuing appropriate touch events. */
func (t *Tab) InputSynthesizeTapGesture(x float64, y float64, duration int, tapCount int, gestureSourceType InputGestureSourceType) (InputSynthesizeTapGestureReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["x"] = x
	
	
	
	params_["y"] = y
	
	
	
	if !isZero(duration) {
		params_["duration"] = duration
	}
	
	
	
	if !isZero(tapCount) {
		params_["tapCount"] = tapCount
	}
	
	
	
	if !isZero(gestureSourceType) {
		params_["gestureSourceType"] = gestureSourceType
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Input.synthesizeTapGesture",
		"params": params_,
	})

	var returns_ InputSynthesizeTapGestureReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InspectorDisableReturns struct {
	
}

/* Disables inspector domain notifications. */
func (t *Tab) InspectorDisable() (InspectorDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Inspector.disable",
		"params": params_,
	})

	var returns_ InspectorDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type InspectorEnableReturns struct {
	
}

/* Enables inspector domain notifications. */
func (t *Tab) InspectorEnable() (InspectorEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Inspector.enable",
		"params": params_,
	})

	var returns_ InspectorEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeCompositingReasonsReturns struct {
	
	CompositingReasons []string
	
}

/* Provides the reasons why the given layer was composited. */
func (t *Tab) LayerTreeCompositingReasons(layerId LayerTreeLayerId) (LayerTreeCompositingReasonsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["layerId"] = layerId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.compositingReasons",
		"params": params_,
	})

	var returns_ LayerTreeCompositingReasonsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeDisableReturns struct {
	
}

/* Disables compositing tree inspection. */
func (t *Tab) LayerTreeDisable() (LayerTreeDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.disable",
		"params": params_,
	})

	var returns_ LayerTreeDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeEnableReturns struct {
	
}

/* Enables compositing tree inspection. */
func (t *Tab) LayerTreeEnable() (LayerTreeEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.enable",
		"params": params_,
	})

	var returns_ LayerTreeEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeLoadSnapshotReturns struct {
	
	SnapshotId LayerTreeSnapshotId
	
}

/* Returns the snapshot identifier. */
func (t *Tab) LayerTreeLoadSnapshot(tiles []LayerTreePictureTile) (LayerTreeLoadSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["tiles"] = tiles
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.loadSnapshot",
		"params": params_,
	})

	var returns_ LayerTreeLoadSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeMakeSnapshotReturns struct {
	
	SnapshotId LayerTreeSnapshotId
	
}

/* Returns the layer snapshot identifier. */
func (t *Tab) LayerTreeMakeSnapshot(layerId LayerTreeLayerId) (LayerTreeMakeSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["layerId"] = layerId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.makeSnapshot",
		"params": params_,
	})

	var returns_ LayerTreeMakeSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeProfileSnapshotReturns struct {
	
	Timings []LayerTreePaintProfile
	
}

/*  */
func (t *Tab) LayerTreeProfileSnapshot(snapshotId LayerTreeSnapshotId, minRepeatCount int, minDuration float64, clipRect DOMRect) (LayerTreeProfileSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["snapshotId"] = snapshotId
	
	
	
	if !isZero(minRepeatCount) {
		params_["minRepeatCount"] = minRepeatCount
	}
	
	
	
	if !isZero(minDuration) {
		params_["minDuration"] = minDuration
	}
	
	
	
	if !isZero(clipRect) {
		params_["clipRect"] = clipRect
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.profileSnapshot",
		"params": params_,
	})

	var returns_ LayerTreeProfileSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeReleaseSnapshotReturns struct {
	
}

/* Releases layer snapshot captured by the back-end. */
func (t *Tab) LayerTreeReleaseSnapshot(snapshotId LayerTreeSnapshotId) (LayerTreeReleaseSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["snapshotId"] = snapshotId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.releaseSnapshot",
		"params": params_,
	})

	var returns_ LayerTreeReleaseSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeReplaySnapshotReturns struct {
	
	DataURL string
	
}

/* Replays the layer snapshot and returns the resulting bitmap. */
func (t *Tab) LayerTreeReplaySnapshot(snapshotId LayerTreeSnapshotId, fromStep int, toStep int, scale float64) (LayerTreeReplaySnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["snapshotId"] = snapshotId
	
	
	
	if !isZero(fromStep) {
		params_["fromStep"] = fromStep
	}
	
	
	
	if !isZero(toStep) {
		params_["toStep"] = toStep
	}
	
	
	
	if !isZero(scale) {
		params_["scale"] = scale
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.replaySnapshot",
		"params": params_,
	})

	var returns_ LayerTreeReplaySnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LayerTreeSnapshotCommandLogReturns struct {
	
	CommandLog []map[string]interface{}
	
}

/* Replays the layer snapshot and returns canvas log. */
func (t *Tab) LayerTreeSnapshotCommandLog(snapshotId LayerTreeSnapshotId) (LayerTreeSnapshotCommandLogReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["snapshotId"] = snapshotId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "LayerTree.snapshotCommandLog",
		"params": params_,
	})

	var returns_ LayerTreeSnapshotCommandLogReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LogClearReturns struct {
	
}

/* Clears the log. */
func (t *Tab) LogClear() (LogClearReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Log.clear",
		"params": params_,
	})

	var returns_ LogClearReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LogDisableReturns struct {
	
}

/* Disables log domain, prevents further log entries from being reported to the client. */
func (t *Tab) LogDisable() (LogDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Log.disable",
		"params": params_,
	})

	var returns_ LogDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LogEnableReturns struct {
	
}

/* Enables log domain, sends the entries collected so far to the client by means of the
`entryAdded` notification. */
func (t *Tab) LogEnable() (LogEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Log.enable",
		"params": params_,
	})

	var returns_ LogEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LogStartViolationsReportReturns struct {
	
}

/* start violation reporting. */
func (t *Tab) LogStartViolationsReport(config []LogViolationSetting) (LogStartViolationsReportReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["config"] = config
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Log.startViolationsReport",
		"params": params_,
	})

	var returns_ LogStartViolationsReportReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type LogStopViolationsReportReturns struct {
	
}

/* Stop violation reporting. */
func (t *Tab) LogStopViolationsReport() (LogStopViolationsReportReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Log.stopViolationsReport",
		"params": params_,
	})

	var returns_ LogStopViolationsReportReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryGetDOMCountersReturns struct {
	
	Documents int
	
	Nodes int
	
	JsEventListeners int
	
}

/*  */
func (t *Tab) MemoryGetDOMCounters() (MemoryGetDOMCountersReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.getDOMCounters",
		"params": params_,
	})

	var returns_ MemoryGetDOMCountersReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryPrepareForLeakDetectionReturns struct {
	
}

/*  */
func (t *Tab) MemoryPrepareForLeakDetection() (MemoryPrepareForLeakDetectionReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.prepareForLeakDetection",
		"params": params_,
	})

	var returns_ MemoryPrepareForLeakDetectionReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryForciblyPurgeJavaScriptMemoryReturns struct {
	
}

/* Simulate OomIntervention by purging V8 memory. */
func (t *Tab) MemoryForciblyPurgeJavaScriptMemory() (MemoryForciblyPurgeJavaScriptMemoryReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.forciblyPurgeJavaScriptMemory",
		"params": params_,
	})

	var returns_ MemoryForciblyPurgeJavaScriptMemoryReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemorySetPressureNotificationsSuppressedReturns struct {
	
}

/* Enable/disable suppressing memory pressure notifications in all processes. */
func (t *Tab) MemorySetPressureNotificationsSuppressed(suppressed bool) (MemorySetPressureNotificationsSuppressedReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["suppressed"] = suppressed
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.setPressureNotificationsSuppressed",
		"params": params_,
	})

	var returns_ MemorySetPressureNotificationsSuppressedReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemorySimulatePressureNotificationReturns struct {
	
}

/* Simulate a memory pressure notification in all processes. */
func (t *Tab) MemorySimulatePressureNotification(level MemoryPressureLevel) (MemorySimulatePressureNotificationReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["level"] = level
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.simulatePressureNotification",
		"params": params_,
	})

	var returns_ MemorySimulatePressureNotificationReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryStartSamplingReturns struct {
	
}

/* Start collecting native memory profile. */
func (t *Tab) MemoryStartSampling(samplingInterval int, suppressRandomness bool) (MemoryStartSamplingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(samplingInterval) {
		params_["samplingInterval"] = samplingInterval
	}
	
	
	
	if !isZero(suppressRandomness) {
		params_["suppressRandomness"] = suppressRandomness
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.startSampling",
		"params": params_,
	})

	var returns_ MemoryStartSamplingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryStopSamplingReturns struct {
	
}

/* Stop collecting native memory profile. */
func (t *Tab) MemoryStopSampling() (MemoryStopSamplingReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.stopSampling",
		"params": params_,
	})

	var returns_ MemoryStopSamplingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryGetAllTimeSamplingProfileReturns struct {
	
	Profile MemorySamplingProfile
	
}

/* Retrieve native memory allocations profile
collected since renderer process startup. */
func (t *Tab) MemoryGetAllTimeSamplingProfile() (MemoryGetAllTimeSamplingProfileReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.getAllTimeSamplingProfile",
		"params": params_,
	})

	var returns_ MemoryGetAllTimeSamplingProfileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryGetBrowserSamplingProfileReturns struct {
	
	Profile MemorySamplingProfile
	
}

/* Retrieve native memory allocations profile
collected since browser process startup. */
func (t *Tab) MemoryGetBrowserSamplingProfile() (MemoryGetBrowserSamplingProfileReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.getBrowserSamplingProfile",
		"params": params_,
	})

	var returns_ MemoryGetBrowserSamplingProfileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MemoryGetSamplingProfileReturns struct {
	
	Profile MemorySamplingProfile
	
}

/* Retrieve native memory allocations profile collected since last
`startSampling` call. */
func (t *Tab) MemoryGetSamplingProfile() (MemoryGetSamplingProfileReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Memory.getSamplingProfile",
		"params": params_,
	})

	var returns_ MemoryGetSamplingProfileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkCanClearBrowserCacheReturns struct {
	
	Result bool
	
}

/* Tells whether clearing browser cache is supported. */
func (t *Tab) NetworkCanClearBrowserCache() (NetworkCanClearBrowserCacheReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.canClearBrowserCache",
		"params": params_,
	})

	var returns_ NetworkCanClearBrowserCacheReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkCanClearBrowserCookiesReturns struct {
	
	Result bool
	
}

/* Tells whether clearing browser cookies is supported. */
func (t *Tab) NetworkCanClearBrowserCookies() (NetworkCanClearBrowserCookiesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.canClearBrowserCookies",
		"params": params_,
	})

	var returns_ NetworkCanClearBrowserCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkCanEmulateNetworkConditionsReturns struct {
	
	Result bool
	
}

/* Tells whether emulation of network conditions is supported. */
func (t *Tab) NetworkCanEmulateNetworkConditions() (NetworkCanEmulateNetworkConditionsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.canEmulateNetworkConditions",
		"params": params_,
	})

	var returns_ NetworkCanEmulateNetworkConditionsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkClearBrowserCacheReturns struct {
	
}

/* Clears browser cache. */
func (t *Tab) NetworkClearBrowserCache() (NetworkClearBrowserCacheReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.clearBrowserCache",
		"params": params_,
	})

	var returns_ NetworkClearBrowserCacheReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkClearBrowserCookiesReturns struct {
	
}

/* Clears browser cookies. */
func (t *Tab) NetworkClearBrowserCookies() (NetworkClearBrowserCookiesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.clearBrowserCookies",
		"params": params_,
	})

	var returns_ NetworkClearBrowserCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkContinueInterceptedRequestReturns struct {
	
}

/* Response to Network.requestIntercepted which either modifies the request to continue with any
modifications, or blocks it, or completes it with the provided response bytes. If a network
fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
event will be sent with the same InterceptionId.
Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead. */
func (t *Tab) NetworkContinueInterceptedRequest(interceptionId NetworkInterceptionId, errorReason NetworkErrorReason, rawResponse []byte, url string, method string, postData string, headers NetworkHeaders, authChallengeResponse NetworkAuthChallengeResponse) (NetworkContinueInterceptedRequestReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["interceptionId"] = interceptionId
	
	
	
	if !isZero(errorReason) {
		params_["errorReason"] = errorReason
	}
	
	
	
	if !isZero(rawResponse) {
		params_["rawResponse"] = rawResponse
	}
	
	
	
	if !isZero(url) {
		params_["url"] = url
	}
	
	
	
	if !isZero(method) {
		params_["method"] = method
	}
	
	
	
	if !isZero(postData) {
		params_["postData"] = postData
	}
	
	
	
	if !isZero(headers) {
		params_["headers"] = headers
	}
	
	
	
	if !isZero(authChallengeResponse) {
		params_["authChallengeResponse"] = authChallengeResponse
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.continueInterceptedRequest",
		"params": params_,
	})

	var returns_ NetworkContinueInterceptedRequestReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkDeleteCookiesReturns struct {
	
}

/* Deletes browser cookies with matching name and url or domain/path pair. */
func (t *Tab) NetworkDeleteCookies(name string, url string, domain string, path string) (NetworkDeleteCookiesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["name"] = name
	
	
	
	if !isZero(url) {
		params_["url"] = url
	}
	
	
	
	if !isZero(domain) {
		params_["domain"] = domain
	}
	
	
	
	if !isZero(path) {
		params_["path"] = path
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.deleteCookies",
		"params": params_,
	})

	var returns_ NetworkDeleteCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkDisableReturns struct {
	
}

/* Disables network tracking, prevents network events from being sent to the client. */
func (t *Tab) NetworkDisable() (NetworkDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.disable",
		"params": params_,
	})

	var returns_ NetworkDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkEmulateNetworkConditionsReturns struct {
	
}

/* Activates emulation of network conditions. */
func (t *Tab) NetworkEmulateNetworkConditions(offline bool, latency float64, downloadThroughput float64, uploadThroughput float64, connectionType NetworkConnectionType) (NetworkEmulateNetworkConditionsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["offline"] = offline
	
	
	
	params_["latency"] = latency
	
	
	
	params_["downloadThroughput"] = downloadThroughput
	
	
	
	params_["uploadThroughput"] = uploadThroughput
	
	
	
	if !isZero(connectionType) {
		params_["connectionType"] = connectionType
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.emulateNetworkConditions",
		"params": params_,
	})

	var returns_ NetworkEmulateNetworkConditionsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkEnableReturns struct {
	
}

/* Enables network tracking, network events will now be delivered to the client. */
func (t *Tab) NetworkEnable(maxTotalBufferSize int, maxResourceBufferSize int, maxPostDataSize int) (NetworkEnableReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(maxTotalBufferSize) {
		params_["maxTotalBufferSize"] = maxTotalBufferSize
	}
	
	
	
	if !isZero(maxResourceBufferSize) {
		params_["maxResourceBufferSize"] = maxResourceBufferSize
	}
	
	
	
	if !isZero(maxPostDataSize) {
		params_["maxPostDataSize"] = maxPostDataSize
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.enable",
		"params": params_,
	})

	var returns_ NetworkEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkGetAllCookiesReturns struct {
	
	Cookies []NetworkCookie
	
}

/* Returns all browser cookies. Depending on the backend support, will return detailed cookie
information in the `cookies` field. */
func (t *Tab) NetworkGetAllCookies() (NetworkGetAllCookiesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.getAllCookies",
		"params": params_,
	})

	var returns_ NetworkGetAllCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkGetCertificateReturns struct {
	
	TableNames []string
	
}

/* Returns the DER-encoded certificate. */
func (t *Tab) NetworkGetCertificate(origin string) (NetworkGetCertificateReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.getCertificate",
		"params": params_,
	})

	var returns_ NetworkGetCertificateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkGetCookiesReturns struct {
	
	Cookies []NetworkCookie
	
}

/* Returns all browser cookies for the current URL. Depending on the backend support, will return
detailed cookie information in the `cookies` field. */
func (t *Tab) NetworkGetCookies(urls []string) (NetworkGetCookiesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(urls) {
		params_["urls"] = urls
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.getCookies",
		"params": params_,
	})

	var returns_ NetworkGetCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkGetResponseBodyReturns struct {
	
	Body string
	
	Base64Encoded bool
	
}

/* Returns content served for the given request. */
func (t *Tab) NetworkGetResponseBody(requestId NetworkRequestId) (NetworkGetResponseBodyReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.getResponseBody",
		"params": params_,
	})

	var returns_ NetworkGetResponseBodyReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkGetRequestPostDataReturns struct {
	
	PostData string
	
}

/* Returns post data sent with the request. Returns an error when no data was sent with the request. */
func (t *Tab) NetworkGetRequestPostData(requestId NetworkRequestId) (NetworkGetRequestPostDataReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.getRequestPostData",
		"params": params_,
	})

	var returns_ NetworkGetRequestPostDataReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkGetResponseBodyForInterceptionReturns struct {
	
	Body string
	
	Base64Encoded bool
	
}

/* Returns content served for the given currently intercepted request. */
func (t *Tab) NetworkGetResponseBodyForInterception(interceptionId NetworkInterceptionId) (NetworkGetResponseBodyForInterceptionReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["interceptionId"] = interceptionId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.getResponseBodyForInterception",
		"params": params_,
	})

	var returns_ NetworkGetResponseBodyForInterceptionReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkTakeResponseBodyForInterceptionAsStreamReturns struct {
	
	Stream IOStreamHandle
	
}

/* Returns a handle to the stream representing the response body. Note that after this command,
the intercepted request can't be continued as is -- you either need to cancel it or to provide
the response body. The stream only supports sequential read, IO.read will fail if the position
is specified. */
func (t *Tab) NetworkTakeResponseBodyForInterceptionAsStream(interceptionId NetworkInterceptionId) (NetworkTakeResponseBodyForInterceptionAsStreamReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["interceptionId"] = interceptionId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.takeResponseBodyForInterceptionAsStream",
		"params": params_,
	})

	var returns_ NetworkTakeResponseBodyForInterceptionAsStreamReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkReplayXHRReturns struct {
	
}

/* This method sends a new XMLHttpRequest which is identical to the original one. The following
parameters should be identical: method, url, async, request body, extra headers, withCredentials
attribute, user, password. */
func (t *Tab) NetworkReplayXHR(requestId NetworkRequestId) (NetworkReplayXHRReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.replayXHR",
		"params": params_,
	})

	var returns_ NetworkReplayXHRReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSearchInResponseBodyReturns struct {
	
	Result []DebuggerSearchMatch
	
}

/* Searches for given string in response content. */
func (t *Tab) NetworkSearchInResponseBody(requestId NetworkRequestId, query string, caseSensitive bool, isRegex bool) (NetworkSearchInResponseBodyReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	
	
	params_["query"] = query
	
	
	
	if !isZero(caseSensitive) {
		params_["caseSensitive"] = caseSensitive
	}
	
	
	
	if !isZero(isRegex) {
		params_["isRegex"] = isRegex
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.searchInResponseBody",
		"params": params_,
	})

	var returns_ NetworkSearchInResponseBodyReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetBlockedURLsReturns struct {
	
}

/* Blocks URLs from loading. */
func (t *Tab) NetworkSetBlockedURLs(urls []string) (NetworkSetBlockedURLsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["urls"] = urls
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setBlockedURLs",
		"params": params_,
	})

	var returns_ NetworkSetBlockedURLsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetBypassServiceWorkerReturns struct {
	
}

/* Toggles ignoring of service worker for each request. */
func (t *Tab) NetworkSetBypassServiceWorker(bypass bool) (NetworkSetBypassServiceWorkerReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["bypass"] = bypass
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setBypassServiceWorker",
		"params": params_,
	})

	var returns_ NetworkSetBypassServiceWorkerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetCacheDisabledReturns struct {
	
}

/* Toggles ignoring cache for each request. If `true`, cache will not be used. */
func (t *Tab) NetworkSetCacheDisabled(cacheDisabled bool) (NetworkSetCacheDisabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cacheDisabled"] = cacheDisabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setCacheDisabled",
		"params": params_,
	})

	var returns_ NetworkSetCacheDisabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetCookieReturns struct {
	
	Success bool
	
}

/* Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. */
func (t *Tab) NetworkSetCookie(name string, value string, url string, domain string, path string, secure bool, httpOnly bool, sameSite NetworkCookieSameSite, expires NetworkTimeSinceEpoch) (NetworkSetCookieReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["name"] = name
	
	
	
	params_["value"] = value
	
	
	
	if !isZero(url) {
		params_["url"] = url
	}
	
	
	
	if !isZero(domain) {
		params_["domain"] = domain
	}
	
	
	
	if !isZero(path) {
		params_["path"] = path
	}
	
	
	
	if !isZero(secure) {
		params_["secure"] = secure
	}
	
	
	
	if !isZero(httpOnly) {
		params_["httpOnly"] = httpOnly
	}
	
	
	
	if !isZero(sameSite) {
		params_["sameSite"] = sameSite
	}
	
	
	
	if !isZero(expires) {
		params_["expires"] = expires
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setCookie",
		"params": params_,
	})

	var returns_ NetworkSetCookieReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetCookiesReturns struct {
	
}

/* Sets given cookies. */
func (t *Tab) NetworkSetCookies(cookies []NetworkCookieParam) (NetworkSetCookiesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cookies"] = cookies
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setCookies",
		"params": params_,
	})

	var returns_ NetworkSetCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetDataSizeLimitsForTestReturns struct {
	
}

/* For testing. */
func (t *Tab) NetworkSetDataSizeLimitsForTest(maxTotalSize int, maxResourceSize int) (NetworkSetDataSizeLimitsForTestReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["maxTotalSize"] = maxTotalSize
	
	
	
	params_["maxResourceSize"] = maxResourceSize
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setDataSizeLimitsForTest",
		"params": params_,
	})

	var returns_ NetworkSetDataSizeLimitsForTestReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetExtraHTTPHeadersReturns struct {
	
}

/* Specifies whether to always send extra HTTP headers with the requests from this page. */
func (t *Tab) NetworkSetExtraHTTPHeaders(headers NetworkHeaders) (NetworkSetExtraHTTPHeadersReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["headers"] = headers
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setExtraHTTPHeaders",
		"params": params_,
	})

	var returns_ NetworkSetExtraHTTPHeadersReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetRequestInterceptionReturns struct {
	
}

/* Sets the requests to intercept that match the provided patterns and optionally resource types.
Deprecated, please use Fetch.enable instead. */
func (t *Tab) NetworkSetRequestInterception(patterns []NetworkRequestPattern) (NetworkSetRequestInterceptionReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["patterns"] = patterns
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setRequestInterception",
		"params": params_,
	})

	var returns_ NetworkSetRequestInterceptionReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type NetworkSetUserAgentOverrideReturns struct {
	
}

/* Allows overriding user agent with the given string. */
func (t *Tab) NetworkSetUserAgentOverride(userAgent string, acceptLanguage string, platform string) (NetworkSetUserAgentOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["userAgent"] = userAgent
	
	
	
	if !isZero(acceptLanguage) {
		params_["acceptLanguage"] = acceptLanguage
	}
	
	
	
	if !isZero(platform) {
		params_["platform"] = platform
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Network.setUserAgentOverride",
		"params": params_,
	})

	var returns_ NetworkSetUserAgentOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayDisableReturns struct {
	
}

/* Disables domain notifications. */
func (t *Tab) OverlayDisable() (OverlayDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.disable",
		"params": params_,
	})

	var returns_ OverlayDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayEnableReturns struct {
	
}

/* Enables domain notifications. */
func (t *Tab) OverlayEnable() (OverlayEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.enable",
		"params": params_,
	})

	var returns_ OverlayEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayGetHighlightObjectForTestReturns struct {
	
	Highlight map[string]interface{}
	
}

/* For testing. */
func (t *Tab) OverlayGetHighlightObjectForTest(nodeId DOMNodeId, includeDistance bool, includeStyle bool) (OverlayGetHighlightObjectForTestReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["nodeId"] = nodeId
	
	
	
	if !isZero(includeDistance) {
		params_["includeDistance"] = includeDistance
	}
	
	
	
	if !isZero(includeStyle) {
		params_["includeStyle"] = includeStyle
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.getHighlightObjectForTest",
		"params": params_,
	})

	var returns_ OverlayGetHighlightObjectForTestReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayHideHighlightReturns struct {
	
}

/* Hides any highlight. */
func (t *Tab) OverlayHideHighlight() (OverlayHideHighlightReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.hideHighlight",
		"params": params_,
	})

	var returns_ OverlayHideHighlightReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayHighlightFrameReturns struct {
	
}

/* Highlights owner element of the frame with given id. */
func (t *Tab) OverlayHighlightFrame(frameId PageFrameId, contentColor DOMRGBA, contentOutlineColor DOMRGBA) (OverlayHighlightFrameReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	
	
	if !isZero(contentColor) {
		params_["contentColor"] = contentColor
	}
	
	
	
	if !isZero(contentOutlineColor) {
		params_["contentOutlineColor"] = contentOutlineColor
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.highlightFrame",
		"params": params_,
	})

	var returns_ OverlayHighlightFrameReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayHighlightNodeReturns struct {
	
}

/* Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
objectId must be specified. */
func (t *Tab) OverlayHighlightNode(highlightConfig OverlayHighlightConfig, nodeId DOMNodeId, backendNodeId DOMBackendNodeId, objectId RuntimeRemoteObjectId, selector string) (OverlayHighlightNodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["highlightConfig"] = highlightConfig
	
	
	
	if !isZero(nodeId) {
		params_["nodeId"] = nodeId
	}
	
	
	
	if !isZero(backendNodeId) {
		params_["backendNodeId"] = backendNodeId
	}
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	
	
	if !isZero(selector) {
		params_["selector"] = selector
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.highlightNode",
		"params": params_,
	})

	var returns_ OverlayHighlightNodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayHighlightQuadReturns struct {
	
}

/* Highlights given quad. Coordinates are absolute with respect to the main frame viewport. */
func (t *Tab) OverlayHighlightQuad(quad DOMQuad, color DOMRGBA, outlineColor DOMRGBA) (OverlayHighlightQuadReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["quad"] = quad
	
	
	
	if !isZero(color) {
		params_["color"] = color
	}
	
	
	
	if !isZero(outlineColor) {
		params_["outlineColor"] = outlineColor
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.highlightQuad",
		"params": params_,
	})

	var returns_ OverlayHighlightQuadReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlayHighlightRectReturns struct {
	
}

/* Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport. */
func (t *Tab) OverlayHighlightRect(x int, y int, width int, height int, color DOMRGBA, outlineColor DOMRGBA) (OverlayHighlightRectReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["x"] = x
	
	
	
	params_["y"] = y
	
	
	
	params_["width"] = width
	
	
	
	params_["height"] = height
	
	
	
	if !isZero(color) {
		params_["color"] = color
	}
	
	
	
	if !isZero(outlineColor) {
		params_["outlineColor"] = outlineColor
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.highlightRect",
		"params": params_,
	})

	var returns_ OverlayHighlightRectReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetInspectModeReturns struct {
	
}

/* Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
Backend then generates 'inspectNodeRequested' event upon element selection. */
func (t *Tab) OverlaySetInspectMode(mode OverlayInspectMode, highlightConfig OverlayHighlightConfig) (OverlaySetInspectModeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["mode"] = mode
	
	
	
	if !isZero(highlightConfig) {
		params_["highlightConfig"] = highlightConfig
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setInspectMode",
		"params": params_,
	})

	var returns_ OverlaySetInspectModeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowAdHighlightsReturns struct {
	
}

/* Highlights owner element of all frames detected to be ads. */
func (t *Tab) OverlaySetShowAdHighlights(show bool) (OverlaySetShowAdHighlightsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["show"] = show
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowAdHighlights",
		"params": params_,
	})

	var returns_ OverlaySetShowAdHighlightsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetPausedInDebuggerMessageReturns struct {
	
}

/*  */
func (t *Tab) OverlaySetPausedInDebuggerMessage(message string) (OverlaySetPausedInDebuggerMessageReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(message) {
		params_["message"] = message
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setPausedInDebuggerMessage",
		"params": params_,
	})

	var returns_ OverlaySetPausedInDebuggerMessageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowDebugBordersReturns struct {
	
}

/* Requests that backend shows debug borders on layers */
func (t *Tab) OverlaySetShowDebugBorders(show bool) (OverlaySetShowDebugBordersReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["show"] = show
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowDebugBorders",
		"params": params_,
	})

	var returns_ OverlaySetShowDebugBordersReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowFPSCounterReturns struct {
	
}

/* Requests that backend shows the FPS counter */
func (t *Tab) OverlaySetShowFPSCounter(show bool) (OverlaySetShowFPSCounterReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["show"] = show
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowFPSCounter",
		"params": params_,
	})

	var returns_ OverlaySetShowFPSCounterReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowPaintRectsReturns struct {
	
}

/* Requests that backend shows paint rectangles */
func (t *Tab) OverlaySetShowPaintRects(result bool) (OverlaySetShowPaintRectsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["result"] = result
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowPaintRects",
		"params": params_,
	})

	var returns_ OverlaySetShowPaintRectsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowLayoutShiftRegionsReturns struct {
	
}

/* Requests that backend shows layout shift regions */
func (t *Tab) OverlaySetShowLayoutShiftRegions(result bool) (OverlaySetShowLayoutShiftRegionsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["result"] = result
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowLayoutShiftRegions",
		"params": params_,
	})

	var returns_ OverlaySetShowLayoutShiftRegionsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowScrollBottleneckRectsReturns struct {
	
}

/* Requests that backend shows scroll bottleneck rects */
func (t *Tab) OverlaySetShowScrollBottleneckRects(show bool) (OverlaySetShowScrollBottleneckRectsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["show"] = show
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowScrollBottleneckRects",
		"params": params_,
	})

	var returns_ OverlaySetShowScrollBottleneckRectsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowHitTestBordersReturns struct {
	
}

/* Requests that backend shows hit-test borders on layers */
func (t *Tab) OverlaySetShowHitTestBorders(show bool) (OverlaySetShowHitTestBordersReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["show"] = show
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowHitTestBorders",
		"params": params_,
	})

	var returns_ OverlaySetShowHitTestBordersReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type OverlaySetShowViewportSizeOnResizeReturns struct {
	
}

/* Paints viewport size upon main frame resize. */
func (t *Tab) OverlaySetShowViewportSizeOnResize(show bool) (OverlaySetShowViewportSizeOnResizeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["show"] = show
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Overlay.setShowViewportSizeOnResize",
		"params": params_,
	})

	var returns_ OverlaySetShowViewportSizeOnResizeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageAddScriptToEvaluateOnLoadReturns struct {
	
	Identifier PageScriptIdentifier
	
}

/* Deprecated, please use addScriptToEvaluateOnNewDocument instead. */
func (t *Tab) PageAddScriptToEvaluateOnLoad(scriptSource string) (PageAddScriptToEvaluateOnLoadReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scriptSource"] = scriptSource
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.addScriptToEvaluateOnLoad",
		"params": params_,
	})

	var returns_ PageAddScriptToEvaluateOnLoadReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageAddScriptToEvaluateOnNewDocumentReturns struct {
	
	Identifier PageScriptIdentifier
	
}

/* Evaluates given script in every frame upon creation (before loading frame's scripts). */
func (t *Tab) PageAddScriptToEvaluateOnNewDocument(source string, worldName string) (PageAddScriptToEvaluateOnNewDocumentReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["source"] = source
	
	
	
	if !isZero(worldName) {
		params_["worldName"] = worldName
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.addScriptToEvaluateOnNewDocument",
		"params": params_,
	})

	var returns_ PageAddScriptToEvaluateOnNewDocumentReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageBringToFrontReturns struct {
	
}

/* Brings page to front (activates tab). */
func (t *Tab) PageBringToFront() (PageBringToFrontReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.bringToFront",
		"params": params_,
	})

	var returns_ PageBringToFrontReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageCaptureScreenshotReturns struct {
	
	Data []byte
	
}

/* Capture page screenshot. */
func (t *Tab) PageCaptureScreenshot(format string, quality int, clip PageViewport, fromSurface bool) (PageCaptureScreenshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(format) {
		params_["format"] = format
	}
	
	
	
	if !isZero(quality) {
		params_["quality"] = quality
	}
	
	
	
	if !isZero(clip) {
		params_["clip"] = clip
	}
	
	
	
	if !isZero(fromSurface) {
		params_["fromSurface"] = fromSurface
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.captureScreenshot",
		"params": params_,
	})

	var returns_ PageCaptureScreenshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageCaptureSnapshotReturns struct {
	
	Data string
	
}

/* Returns a snapshot of the page as a string. For MHTML format, the serialization includes
iframes, shadow DOM, external resources, and element-inline styles. */
func (t *Tab) PageCaptureSnapshot(format string) (PageCaptureSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(format) {
		params_["format"] = format
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.captureSnapshot",
		"params": params_,
	})

	var returns_ PageCaptureSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageClearDeviceMetricsOverrideReturns struct {
	
}

/* Clears the overriden device metrics. */
func (t *Tab) PageClearDeviceMetricsOverride() (PageClearDeviceMetricsOverrideReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.clearDeviceMetricsOverride",
		"params": params_,
	})

	var returns_ PageClearDeviceMetricsOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageClearDeviceOrientationOverrideReturns struct {
	
}

/* Clears the overridden Device Orientation. */
func (t *Tab) PageClearDeviceOrientationOverride() (PageClearDeviceOrientationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.clearDeviceOrientationOverride",
		"params": params_,
	})

	var returns_ PageClearDeviceOrientationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageClearGeolocationOverrideReturns struct {
	
}

/* Clears the overriden Geolocation Position and Error. */
func (t *Tab) PageClearGeolocationOverride() (PageClearGeolocationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.clearGeolocationOverride",
		"params": params_,
	})

	var returns_ PageClearGeolocationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageCreateIsolatedWorldReturns struct {
	
	ExecutionContextId RuntimeExecutionContextId
	
}

/* Creates an isolated world for the given frame. */
func (t *Tab) PageCreateIsolatedWorld(frameId PageFrameId, worldName string, grantUniveralAccess bool) (PageCreateIsolatedWorldReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	
	
	if !isZero(worldName) {
		params_["worldName"] = worldName
	}
	
	
	
	if !isZero(grantUniveralAccess) {
		params_["grantUniveralAccess"] = grantUniveralAccess
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.createIsolatedWorld",
		"params": params_,
	})

	var returns_ PageCreateIsolatedWorldReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageDeleteCookieReturns struct {
	
}

/* Deletes browser cookie with given name, domain and path. */
func (t *Tab) PageDeleteCookie(cookieName string, url string) (PageDeleteCookieReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cookieName"] = cookieName
	
	
	
	params_["url"] = url
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.deleteCookie",
		"params": params_,
	})

	var returns_ PageDeleteCookieReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageDisableReturns struct {
	
}

/* Disables page domain notifications. */
func (t *Tab) PageDisable() (PageDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.disable",
		"params": params_,
	})

	var returns_ PageDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageEnableReturns struct {
	
}

/* Enables page domain notifications. */
func (t *Tab) PageEnable() (PageEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.enable",
		"params": params_,
	})

	var returns_ PageEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetAppManifestReturns struct {
	
	Url string
	
	Errors []PageAppManifestError
	
	Data string
	
}

/*  */
func (t *Tab) PageGetAppManifest() (PageGetAppManifestReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getAppManifest",
		"params": params_,
	})

	var returns_ PageGetAppManifestReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetInstallabilityErrorsReturns struct {
	
	Errors []string
	
}

/*  */
func (t *Tab) PageGetInstallabilityErrors() (PageGetInstallabilityErrorsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getInstallabilityErrors",
		"params": params_,
	})

	var returns_ PageGetInstallabilityErrorsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetCookiesReturns struct {
	
	Cookies []NetworkCookie
	
}

/* Returns all browser cookies. Depending on the backend support, will return detailed cookie
information in the `cookies` field. */
func (t *Tab) PageGetCookies() (PageGetCookiesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getCookies",
		"params": params_,
	})

	var returns_ PageGetCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetFrameTreeReturns struct {
	
	FrameTree PageFrameTree
	
}

/* Returns present frame tree structure. */
func (t *Tab) PageGetFrameTree() (PageGetFrameTreeReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getFrameTree",
		"params": params_,
	})

	var returns_ PageGetFrameTreeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetLayoutMetricsReturns struct {
	
	LayoutViewport PageLayoutViewport
	
	VisualViewport PageVisualViewport
	
	ContentSize DOMRect
	
}

/* Returns metrics relating to the layouting of the page, such as viewport bounds/scale. */
func (t *Tab) PageGetLayoutMetrics() (PageGetLayoutMetricsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getLayoutMetrics",
		"params": params_,
	})

	var returns_ PageGetLayoutMetricsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetNavigationHistoryReturns struct {
	
	CurrentIndex int
	
	Entries []PageNavigationEntry
	
}

/* Returns navigation history for the current page. */
func (t *Tab) PageGetNavigationHistory() (PageGetNavigationHistoryReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getNavigationHistory",
		"params": params_,
	})

	var returns_ PageGetNavigationHistoryReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageResetNavigationHistoryReturns struct {
	
}

/* Resets navigation history for the current page. */
func (t *Tab) PageResetNavigationHistory() (PageResetNavigationHistoryReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.resetNavigationHistory",
		"params": params_,
	})

	var returns_ PageResetNavigationHistoryReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetResourceContentReturns struct {
	
	Content string
	
	Base64Encoded bool
	
}

/* Returns content of the given resource. */
func (t *Tab) PageGetResourceContent(frameId PageFrameId, url string) (PageGetResourceContentReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	
	
	params_["url"] = url
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getResourceContent",
		"params": params_,
	})

	var returns_ PageGetResourceContentReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGetResourceTreeReturns struct {
	
	FrameTree PageFrameResourceTree
	
}

/* Returns present frame / resource tree structure. */
func (t *Tab) PageGetResourceTree() (PageGetResourceTreeReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.getResourceTree",
		"params": params_,
	})

	var returns_ PageGetResourceTreeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageHandleJavaScriptDialogReturns struct {
	
}

/* Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). */
func (t *Tab) PageHandleJavaScriptDialog(accept bool, promptText string) (PageHandleJavaScriptDialogReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["accept"] = accept
	
	
	
	if !isZero(promptText) {
		params_["promptText"] = promptText
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.handleJavaScriptDialog",
		"params": params_,
	})

	var returns_ PageHandleJavaScriptDialogReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageNavigateReturns struct {
	
	FrameId PageFrameId
	
	LoaderId NetworkLoaderId
	
	ErrorText string
	
}

/* Navigates current page to the given URL. */
func (t *Tab) PageNavigate(url string, referrer string, transitionType PageTransitionType, frameId PageFrameId) (PageNavigateReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["url"] = url
	
	
	
	if !isZero(referrer) {
		params_["referrer"] = referrer
	}
	
	
	
	if !isZero(transitionType) {
		params_["transitionType"] = transitionType
	}
	
	
	
	if !isZero(frameId) {
		params_["frameId"] = frameId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.navigate",
		"params": params_,
	})

	var returns_ PageNavigateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageNavigateToHistoryEntryReturns struct {
	
}

/* Navigates current page to the given history entry. */
func (t *Tab) PageNavigateToHistoryEntry(entryId int) (PageNavigateToHistoryEntryReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["entryId"] = entryId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.navigateToHistoryEntry",
		"params": params_,
	})

	var returns_ PageNavigateToHistoryEntryReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PagePrintToPDFReturns struct {
	
	Data []byte
	
	Stream IOStreamHandle
	
}

/* Print page as PDF. */
func (t *Tab) PagePrintToPDF(landscape bool, displayHeaderFooter bool, printBackground bool, scale float64, paperWidth float64, paperHeight float64, marginTop float64, marginBottom float64, marginLeft float64, marginRight float64, pageRanges string, ignoreInvalidPageRanges bool, headerTemplate string, footerTemplate string, preferCSSPageSize bool, transferMode string) (PagePrintToPDFReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(landscape) {
		params_["landscape"] = landscape
	}
	
	
	
	if !isZero(displayHeaderFooter) {
		params_["displayHeaderFooter"] = displayHeaderFooter
	}
	
	
	
	if !isZero(printBackground) {
		params_["printBackground"] = printBackground
	}
	
	
	
	if !isZero(scale) {
		params_["scale"] = scale
	}
	
	
	
	if !isZero(paperWidth) {
		params_["paperWidth"] = paperWidth
	}
	
	
	
	if !isZero(paperHeight) {
		params_["paperHeight"] = paperHeight
	}
	
	
	
	if !isZero(marginTop) {
		params_["marginTop"] = marginTop
	}
	
	
	
	if !isZero(marginBottom) {
		params_["marginBottom"] = marginBottom
	}
	
	
	
	if !isZero(marginLeft) {
		params_["marginLeft"] = marginLeft
	}
	
	
	
	if !isZero(marginRight) {
		params_["marginRight"] = marginRight
	}
	
	
	
	if !isZero(pageRanges) {
		params_["pageRanges"] = pageRanges
	}
	
	
	
	if !isZero(ignoreInvalidPageRanges) {
		params_["ignoreInvalidPageRanges"] = ignoreInvalidPageRanges
	}
	
	
	
	if !isZero(headerTemplate) {
		params_["headerTemplate"] = headerTemplate
	}
	
	
	
	if !isZero(footerTemplate) {
		params_["footerTemplate"] = footerTemplate
	}
	
	
	
	if !isZero(preferCSSPageSize) {
		params_["preferCSSPageSize"] = preferCSSPageSize
	}
	
	
	
	if !isZero(transferMode) {
		params_["transferMode"] = transferMode
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.printToPDF",
		"params": params_,
	})

	var returns_ PagePrintToPDFReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageReloadReturns struct {
	
}

/* Reloads given page optionally ignoring the cache. */
func (t *Tab) PageReload(ignoreCache bool, scriptToEvaluateOnLoad string) (PageReloadReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(ignoreCache) {
		params_["ignoreCache"] = ignoreCache
	}
	
	
	
	if !isZero(scriptToEvaluateOnLoad) {
		params_["scriptToEvaluateOnLoad"] = scriptToEvaluateOnLoad
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.reload",
		"params": params_,
	})

	var returns_ PageReloadReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageRemoveScriptToEvaluateOnLoadReturns struct {
	
}

/* Deprecated, please use removeScriptToEvaluateOnNewDocument instead. */
func (t *Tab) PageRemoveScriptToEvaluateOnLoad(identifier PageScriptIdentifier) (PageRemoveScriptToEvaluateOnLoadReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["identifier"] = identifier
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.removeScriptToEvaluateOnLoad",
		"params": params_,
	})

	var returns_ PageRemoveScriptToEvaluateOnLoadReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageRemoveScriptToEvaluateOnNewDocumentReturns struct {
	
}

/* Removes given script from the list. */
func (t *Tab) PageRemoveScriptToEvaluateOnNewDocument(identifier PageScriptIdentifier) (PageRemoveScriptToEvaluateOnNewDocumentReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["identifier"] = identifier
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.removeScriptToEvaluateOnNewDocument",
		"params": params_,
	})

	var returns_ PageRemoveScriptToEvaluateOnNewDocumentReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageScreencastFrameAckReturns struct {
	
}

/* Acknowledges that a screencast frame has been received by the frontend. */
func (t *Tab) PageScreencastFrameAck(sessionId int) (PageScreencastFrameAckReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["sessionId"] = sessionId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.screencastFrameAck",
		"params": params_,
	})

	var returns_ PageScreencastFrameAckReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSearchInResourceReturns struct {
	
	Result []DebuggerSearchMatch
	
}

/* Searches for given string in resource content. */
func (t *Tab) PageSearchInResource(frameId PageFrameId, url string, query string, caseSensitive bool, isRegex bool) (PageSearchInResourceReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	
	
	params_["url"] = url
	
	
	
	params_["query"] = query
	
	
	
	if !isZero(caseSensitive) {
		params_["caseSensitive"] = caseSensitive
	}
	
	
	
	if !isZero(isRegex) {
		params_["isRegex"] = isRegex
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.searchInResource",
		"params": params_,
	})

	var returns_ PageSearchInResourceReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetAdBlockingEnabledReturns struct {
	
}

/* Enable Chrome's experimental ad filter on all sites. */
func (t *Tab) PageSetAdBlockingEnabled(enabled bool) (PageSetAdBlockingEnabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setAdBlockingEnabled",
		"params": params_,
	})

	var returns_ PageSetAdBlockingEnabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetBypassCSPReturns struct {
	
}

/* Enable page Content Security Policy by-passing. */
func (t *Tab) PageSetBypassCSP(enabled bool) (PageSetBypassCSPReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setBypassCSP",
		"params": params_,
	})

	var returns_ PageSetBypassCSPReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetDeviceMetricsOverrideReturns struct {
	
}

/* Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
query results). */
func (t *Tab) PageSetDeviceMetricsOverride(width int, height int, deviceScaleFactor float64, mobile bool, scale float64, screenWidth int, screenHeight int, positionX int, positionY int, dontSetVisibleSize bool, screenOrientation EmulationScreenOrientation, viewport PageViewport) (PageSetDeviceMetricsOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["width"] = width
	
	
	
	params_["height"] = height
	
	
	
	params_["deviceScaleFactor"] = deviceScaleFactor
	
	
	
	params_["mobile"] = mobile
	
	
	
	if !isZero(scale) {
		params_["scale"] = scale
	}
	
	
	
	if !isZero(screenWidth) {
		params_["screenWidth"] = screenWidth
	}
	
	
	
	if !isZero(screenHeight) {
		params_["screenHeight"] = screenHeight
	}
	
	
	
	if !isZero(positionX) {
		params_["positionX"] = positionX
	}
	
	
	
	if !isZero(positionY) {
		params_["positionY"] = positionY
	}
	
	
	
	if !isZero(dontSetVisibleSize) {
		params_["dontSetVisibleSize"] = dontSetVisibleSize
	}
	
	
	
	if !isZero(screenOrientation) {
		params_["screenOrientation"] = screenOrientation
	}
	
	
	
	if !isZero(viewport) {
		params_["viewport"] = viewport
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setDeviceMetricsOverride",
		"params": params_,
	})

	var returns_ PageSetDeviceMetricsOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetDeviceOrientationOverrideReturns struct {
	
}

/* Overrides the Device Orientation. */
func (t *Tab) PageSetDeviceOrientationOverride(alpha float64, beta float64, gamma float64) (PageSetDeviceOrientationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["alpha"] = alpha
	
	
	
	params_["beta"] = beta
	
	
	
	params_["gamma"] = gamma
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setDeviceOrientationOverride",
		"params": params_,
	})

	var returns_ PageSetDeviceOrientationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetFontFamiliesReturns struct {
	
}

/* Set generic font families. */
func (t *Tab) PageSetFontFamilies(fontFamilies PageFontFamilies) (PageSetFontFamiliesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["fontFamilies"] = fontFamilies
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setFontFamilies",
		"params": params_,
	})

	var returns_ PageSetFontFamiliesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetFontSizesReturns struct {
	
}

/* Set default font sizes. */
func (t *Tab) PageSetFontSizes(fontSizes PageFontSizes) (PageSetFontSizesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["fontSizes"] = fontSizes
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setFontSizes",
		"params": params_,
	})

	var returns_ PageSetFontSizesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetDocumentContentReturns struct {
	
}

/* Sets given markup as the document's HTML. */
func (t *Tab) PageSetDocumentContent(frameId PageFrameId, html string) (PageSetDocumentContentReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["frameId"] = frameId
	
	
	
	params_["html"] = html
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setDocumentContent",
		"params": params_,
	})

	var returns_ PageSetDocumentContentReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetDownloadBehaviorReturns struct {
	
}

/* Set the behavior when downloading a file. */
func (t *Tab) PageSetDownloadBehavior(behavior string, downloadPath string) (PageSetDownloadBehaviorReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["behavior"] = behavior
	
	
	
	if !isZero(downloadPath) {
		params_["downloadPath"] = downloadPath
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setDownloadBehavior",
		"params": params_,
	})

	var returns_ PageSetDownloadBehaviorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetGeolocationOverrideReturns struct {
	
}

/* Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
unavailable. */
func (t *Tab) PageSetGeolocationOverride(latitude float64, longitude float64, accuracy float64) (PageSetGeolocationOverrideReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(latitude) {
		params_["latitude"] = latitude
	}
	
	
	
	if !isZero(longitude) {
		params_["longitude"] = longitude
	}
	
	
	
	if !isZero(accuracy) {
		params_["accuracy"] = accuracy
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setGeolocationOverride",
		"params": params_,
	})

	var returns_ PageSetGeolocationOverrideReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetLifecycleEventsEnabledReturns struct {
	
}

/* Controls whether page will emit lifecycle events. */
func (t *Tab) PageSetLifecycleEventsEnabled(enabled bool) (PageSetLifecycleEventsEnabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setLifecycleEventsEnabled",
		"params": params_,
	})

	var returns_ PageSetLifecycleEventsEnabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetTouchEmulationEnabledReturns struct {
	
}

/* Toggles mouse event-based touch event emulation. */
func (t *Tab) PageSetTouchEmulationEnabled(enabled bool, configuration string) (PageSetTouchEmulationEnabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	
	
	if !isZero(configuration) {
		params_["configuration"] = configuration
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setTouchEmulationEnabled",
		"params": params_,
	})

	var returns_ PageSetTouchEmulationEnabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageStartScreencastReturns struct {
	
}

/* Starts sending each frame using the `screencastFrame` event. */
func (t *Tab) PageStartScreencast(format string, quality int, maxWidth int, maxHeight int, everyNthFrame int) (PageStartScreencastReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(format) {
		params_["format"] = format
	}
	
	
	
	if !isZero(quality) {
		params_["quality"] = quality
	}
	
	
	
	if !isZero(maxWidth) {
		params_["maxWidth"] = maxWidth
	}
	
	
	
	if !isZero(maxHeight) {
		params_["maxHeight"] = maxHeight
	}
	
	
	
	if !isZero(everyNthFrame) {
		params_["everyNthFrame"] = everyNthFrame
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.startScreencast",
		"params": params_,
	})

	var returns_ PageStartScreencastReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageStopLoadingReturns struct {
	
}

/* Force the page stop all navigations and pending resource fetches. */
func (t *Tab) PageStopLoading() (PageStopLoadingReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.stopLoading",
		"params": params_,
	})

	var returns_ PageStopLoadingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageCrashReturns struct {
	
}

/* Crashes renderer on the IO thread, generates minidumps. */
func (t *Tab) PageCrash() (PageCrashReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.crash",
		"params": params_,
	})

	var returns_ PageCrashReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageCloseReturns struct {
	
}

/* Tries to close page, running its beforeunload hooks, if any. */
func (t *Tab) PageClose() (PageCloseReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.close",
		"params": params_,
	})

	var returns_ PageCloseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetWebLifecycleStateReturns struct {
	
}

/* Tries to update the web lifecycle state of the page.
It will transition the page to the given state according to:
https://github.com/WICG/web-lifecycle/ */
func (t *Tab) PageSetWebLifecycleState(state string) (PageSetWebLifecycleStateReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["state"] = state
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setWebLifecycleState",
		"params": params_,
	})

	var returns_ PageSetWebLifecycleStateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageStopScreencastReturns struct {
	
}

/* Stops sending each frame in the `screencastFrame`. */
func (t *Tab) PageStopScreencast() (PageStopScreencastReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.stopScreencast",
		"params": params_,
	})

	var returns_ PageStopScreencastReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetProduceCompilationCacheReturns struct {
	
}

/* Forces compilation cache to be generated for every subresource script. */
func (t *Tab) PageSetProduceCompilationCache(enabled bool) (PageSetProduceCompilationCacheReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setProduceCompilationCache",
		"params": params_,
	})

	var returns_ PageSetProduceCompilationCacheReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageAddCompilationCacheReturns struct {
	
}

/* Seeds compilation cache for given url. Compilation cache does not survive
cross-process navigation. */
func (t *Tab) PageAddCompilationCache(url string, data []byte) (PageAddCompilationCacheReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["url"] = url
	
	
	
	params_["data"] = data
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.addCompilationCache",
		"params": params_,
	})

	var returns_ PageAddCompilationCacheReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageClearCompilationCacheReturns struct {
	
}

/* Clears seeded compilation cache. */
func (t *Tab) PageClearCompilationCache() (PageClearCompilationCacheReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.clearCompilationCache",
		"params": params_,
	})

	var returns_ PageClearCompilationCacheReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageGenerateTestReportReturns struct {
	
}

/* Generates a report for testing. */
func (t *Tab) PageGenerateTestReport(message string, group string) (PageGenerateTestReportReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["message"] = message
	
	
	
	if !isZero(group) {
		params_["group"] = group
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.generateTestReport",
		"params": params_,
	})

	var returns_ PageGenerateTestReportReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageWaitForDebuggerReturns struct {
	
}

/* Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger. */
func (t *Tab) PageWaitForDebugger() (PageWaitForDebuggerReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.waitForDebugger",
		"params": params_,
	})

	var returns_ PageWaitForDebuggerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PageSetInterceptFileChooserDialogReturns struct {
	
}

/* Intercept file chooser requests and transfer control to protocol clients.
When file chooser interception is enabled, native file chooser dialog is not shown.
Instead, a protocol event `Page.fileChooserOpened` is emitted. */
func (t *Tab) PageSetInterceptFileChooserDialog(enabled bool) (PageSetInterceptFileChooserDialogReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Page.setInterceptFileChooserDialog",
		"params": params_,
	})

	var returns_ PageSetInterceptFileChooserDialogReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PerformanceDisableReturns struct {
	
}

/* Disable collecting and reporting metrics. */
func (t *Tab) PerformanceDisable() (PerformanceDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Performance.disable",
		"params": params_,
	})

	var returns_ PerformanceDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PerformanceEnableReturns struct {
	
}

/* Enable collecting and reporting metrics. */
func (t *Tab) PerformanceEnable() (PerformanceEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Performance.enable",
		"params": params_,
	})

	var returns_ PerformanceEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PerformanceSetTimeDomainReturns struct {
	
}

/* Sets time domain to use for collecting and reporting duration metrics.
Note that this must be called before enabling metrics collection. Calling
this method while metrics collection is enabled returns an error. */
func (t *Tab) PerformanceSetTimeDomain(timeDomain string) (PerformanceSetTimeDomainReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["timeDomain"] = timeDomain
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Performance.setTimeDomain",
		"params": params_,
	})

	var returns_ PerformanceSetTimeDomainReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type PerformanceGetMetricsReturns struct {
	
	Metrics []PerformanceMetric
	
}

/* Retrieve current values of run-time metrics. */
func (t *Tab) PerformanceGetMetrics() (PerformanceGetMetricsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Performance.getMetrics",
		"params": params_,
	})

	var returns_ PerformanceGetMetricsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SecurityDisableReturns struct {
	
}

/* Disables tracking security state changes. */
func (t *Tab) SecurityDisable() (SecurityDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Security.disable",
		"params": params_,
	})

	var returns_ SecurityDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SecurityEnableReturns struct {
	
}

/* Enables tracking security state changes. */
func (t *Tab) SecurityEnable() (SecurityEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Security.enable",
		"params": params_,
	})

	var returns_ SecurityEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SecuritySetIgnoreCertificateErrorsReturns struct {
	
}

/* Enable/disable whether all certificate errors should be ignored. */
func (t *Tab) SecuritySetIgnoreCertificateErrors(ignore bool) (SecuritySetIgnoreCertificateErrorsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["ignore"] = ignore
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Security.setIgnoreCertificateErrors",
		"params": params_,
	})

	var returns_ SecuritySetIgnoreCertificateErrorsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SecurityHandleCertificateErrorReturns struct {
	
}

/* Handles a certificate error that fired a certificateError event. */
func (t *Tab) SecurityHandleCertificateError(eventId int, action SecurityCertificateErrorAction) (SecurityHandleCertificateErrorReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["eventId"] = eventId
	
	
	
	params_["action"] = action
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Security.handleCertificateError",
		"params": params_,
	})

	var returns_ SecurityHandleCertificateErrorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SecuritySetOverrideCertificateErrorsReturns struct {
	
}

/* Enable/disable overriding certificate errors. If enabled, all certificate error events need to
be handled by the DevTools client and should be answered with `handleCertificateError` commands. */
func (t *Tab) SecuritySetOverrideCertificateErrors(override bool) (SecuritySetOverrideCertificateErrorsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["override"] = override
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Security.setOverrideCertificateErrors",
		"params": params_,
	})

	var returns_ SecuritySetOverrideCertificateErrorsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerDeliverPushMessageReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerDeliverPushMessage(origin string, registrationId ServiceWorkerRegistrationID, data string) (ServiceWorkerDeliverPushMessageReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	
	
	params_["registrationId"] = registrationId
	
	
	
	params_["data"] = data
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.deliverPushMessage",
		"params": params_,
	})

	var returns_ ServiceWorkerDeliverPushMessageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerDisableReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerDisable() (ServiceWorkerDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.disable",
		"params": params_,
	})

	var returns_ ServiceWorkerDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerDispatchSyncEventReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerDispatchSyncEvent(origin string, registrationId ServiceWorkerRegistrationID, tag string, lastChance bool) (ServiceWorkerDispatchSyncEventReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	
	
	params_["registrationId"] = registrationId
	
	
	
	params_["tag"] = tag
	
	
	
	params_["lastChance"] = lastChance
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.dispatchSyncEvent",
		"params": params_,
	})

	var returns_ ServiceWorkerDispatchSyncEventReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerDispatchPeriodicSyncEventReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerDispatchPeriodicSyncEvent(origin string, registrationId ServiceWorkerRegistrationID, tag string) (ServiceWorkerDispatchPeriodicSyncEventReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	
	
	params_["registrationId"] = registrationId
	
	
	
	params_["tag"] = tag
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.dispatchPeriodicSyncEvent",
		"params": params_,
	})

	var returns_ ServiceWorkerDispatchPeriodicSyncEventReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerEnableReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerEnable() (ServiceWorkerEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.enable",
		"params": params_,
	})

	var returns_ ServiceWorkerEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerInspectWorkerReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerInspectWorker(versionId string) (ServiceWorkerInspectWorkerReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["versionId"] = versionId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.inspectWorker",
		"params": params_,
	})

	var returns_ ServiceWorkerInspectWorkerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerSetForceUpdateOnPageLoadReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerSetForceUpdateOnPageLoad(forceUpdateOnPageLoad bool) (ServiceWorkerSetForceUpdateOnPageLoadReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["forceUpdateOnPageLoad"] = forceUpdateOnPageLoad
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.setForceUpdateOnPageLoad",
		"params": params_,
	})

	var returns_ ServiceWorkerSetForceUpdateOnPageLoadReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerSkipWaitingReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerSkipWaiting(scopeURL string) (ServiceWorkerSkipWaitingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scopeURL"] = scopeURL
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.skipWaiting",
		"params": params_,
	})

	var returns_ ServiceWorkerSkipWaitingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerStartWorkerReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerStartWorker(scopeURL string) (ServiceWorkerStartWorkerReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scopeURL"] = scopeURL
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.startWorker",
		"params": params_,
	})

	var returns_ ServiceWorkerStartWorkerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerStopAllWorkersReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerStopAllWorkers() (ServiceWorkerStopAllWorkersReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.stopAllWorkers",
		"params": params_,
	})

	var returns_ ServiceWorkerStopAllWorkersReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerStopWorkerReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerStopWorker(versionId string) (ServiceWorkerStopWorkerReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["versionId"] = versionId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.stopWorker",
		"params": params_,
	})

	var returns_ ServiceWorkerStopWorkerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerUnregisterReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerUnregister(scopeURL string) (ServiceWorkerUnregisterReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scopeURL"] = scopeURL
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.unregister",
		"params": params_,
	})

	var returns_ ServiceWorkerUnregisterReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ServiceWorkerUpdateRegistrationReturns struct {
	
}

/*  */
func (t *Tab) ServiceWorkerUpdateRegistration(scopeURL string) (ServiceWorkerUpdateRegistrationReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scopeURL"] = scopeURL
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "ServiceWorker.updateRegistration",
		"params": params_,
	})

	var returns_ ServiceWorkerUpdateRegistrationReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageClearDataForOriginReturns struct {
	
}

/* Clears storage for origin. */
func (t *Tab) StorageClearDataForOrigin(origin string, storageTypes string) (StorageClearDataForOriginReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	
	
	params_["storageTypes"] = storageTypes
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.clearDataForOrigin",
		"params": params_,
	})

	var returns_ StorageClearDataForOriginReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageGetCookiesReturns struct {
	
	Cookies []NetworkCookie
	
}

/* Returns all browser cookies. */
func (t *Tab) StorageGetCookies(browserContextId BrowserBrowserContextID) (StorageGetCookiesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(browserContextId) {
		params_["browserContextId"] = browserContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.getCookies",
		"params": params_,
	})

	var returns_ StorageGetCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageSetCookiesReturns struct {
	
}

/* Sets given cookies. */
func (t *Tab) StorageSetCookies(cookies []NetworkCookieParam, browserContextId BrowserBrowserContextID) (StorageSetCookiesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["cookies"] = cookies
	
	
	
	if !isZero(browserContextId) {
		params_["browserContextId"] = browserContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.setCookies",
		"params": params_,
	})

	var returns_ StorageSetCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageClearCookiesReturns struct {
	
}

/* Clears cookies. */
func (t *Tab) StorageClearCookies(browserContextId BrowserBrowserContextID) (StorageClearCookiesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(browserContextId) {
		params_["browserContextId"] = browserContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.clearCookies",
		"params": params_,
	})

	var returns_ StorageClearCookiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageGetUsageAndQuotaReturns struct {
	
	Usage float64
	
	Quota float64
	
	UsageBreakdown []StorageUsageForType
	
}

/* Returns usage and quota in bytes. */
func (t *Tab) StorageGetUsageAndQuota(origin string) (StorageGetUsageAndQuotaReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.getUsageAndQuota",
		"params": params_,
	})

	var returns_ StorageGetUsageAndQuotaReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageTrackCacheStorageForOriginReturns struct {
	
}

/* Registers origin to be notified when an update occurs to its cache storage list. */
func (t *Tab) StorageTrackCacheStorageForOrigin(origin string) (StorageTrackCacheStorageForOriginReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.trackCacheStorageForOrigin",
		"params": params_,
	})

	var returns_ StorageTrackCacheStorageForOriginReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageTrackIndexedDBForOriginReturns struct {
	
}

/* Registers origin to be notified when an update occurs to its IndexedDB. */
func (t *Tab) StorageTrackIndexedDBForOrigin(origin string) (StorageTrackIndexedDBForOriginReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.trackIndexedDBForOrigin",
		"params": params_,
	})

	var returns_ StorageTrackIndexedDBForOriginReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageUntrackCacheStorageForOriginReturns struct {
	
}

/* Unregisters origin from receiving notifications for cache storage. */
func (t *Tab) StorageUntrackCacheStorageForOrigin(origin string) (StorageUntrackCacheStorageForOriginReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.untrackCacheStorageForOrigin",
		"params": params_,
	})

	var returns_ StorageUntrackCacheStorageForOriginReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type StorageUntrackIndexedDBForOriginReturns struct {
	
}

/* Unregisters origin from receiving notifications for IndexedDB. */
func (t *Tab) StorageUntrackIndexedDBForOrigin(origin string) (StorageUntrackIndexedDBForOriginReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["origin"] = origin
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Storage.untrackIndexedDBForOrigin",
		"params": params_,
	})

	var returns_ StorageUntrackIndexedDBForOriginReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SystemInfoGetInfoReturns struct {
	
	Gpu SystemInfoGPUInfo
	
	ModelName string
	
	ModelVersion string
	
	CommandLine string
	
}

/* Returns information about the system. */
func (t *Tab) SystemInfoGetInfo() (SystemInfoGetInfoReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "SystemInfo.getInfo",
		"params": params_,
	})

	var returns_ SystemInfoGetInfoReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SystemInfoGetProcessInfoReturns struct {
	
	ProcessInfo []SystemInfoProcessInfo
	
}

/* Returns information about all running processes. */
func (t *Tab) SystemInfoGetProcessInfo() (SystemInfoGetProcessInfoReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "SystemInfo.getProcessInfo",
		"params": params_,
	})

	var returns_ SystemInfoGetProcessInfoReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetActivateTargetReturns struct {
	
}

/* Activates (focuses) the target. */
func (t *Tab) TargetActivateTarget(targetId TargetTargetID) (TargetActivateTargetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["targetId"] = targetId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.activateTarget",
		"params": params_,
	})

	var returns_ TargetActivateTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetAttachToTargetReturns struct {
	
	SessionId TargetSessionID
	
}

/* Attaches to the target with given id. */
func (t *Tab) TargetAttachToTarget(targetId TargetTargetID, flatten bool) (TargetAttachToTargetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["targetId"] = targetId
	
	
	
	if !isZero(flatten) {
		params_["flatten"] = flatten
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.attachToTarget",
		"params": params_,
	})

	var returns_ TargetAttachToTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetAttachToBrowserTargetReturns struct {
	
	SessionId TargetSessionID
	
}

/* Attaches to the browser target, only uses flat sessionId mode. */
func (t *Tab) TargetAttachToBrowserTarget() (TargetAttachToBrowserTargetReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.attachToBrowserTarget",
		"params": params_,
	})

	var returns_ TargetAttachToBrowserTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetCloseTargetReturns struct {
	
	Success bool
	
}

/* Closes the target. If the target is a page that gets closed too. */
func (t *Tab) TargetCloseTarget(targetId TargetTargetID) (TargetCloseTargetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["targetId"] = targetId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.closeTarget",
		"params": params_,
	})

	var returns_ TargetCloseTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetExposeDevToolsProtocolReturns struct {
	
}

/* Inject object to the target's main frame that provides a communication
channel with browser target.

Injected object will be available as `window[bindingName]`.

The object has the follwing API:
- `binding.send(json)` - a method to send messages over the remote debugging protocol
- `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses. */
func (t *Tab) TargetExposeDevToolsProtocol(targetId TargetTargetID, bindingName string) (TargetExposeDevToolsProtocolReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["targetId"] = targetId
	
	
	
	if !isZero(bindingName) {
		params_["bindingName"] = bindingName
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.exposeDevToolsProtocol",
		"params": params_,
	})

	var returns_ TargetExposeDevToolsProtocolReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetCreateBrowserContextReturns struct {
	
	BrowserContextId BrowserBrowserContextID
	
}

/* Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
one. */
func (t *Tab) TargetCreateBrowserContext() (TargetCreateBrowserContextReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.createBrowserContext",
		"params": params_,
	})

	var returns_ TargetCreateBrowserContextReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetGetBrowserContextsReturns struct {
	
	BrowserContextIds []BrowserBrowserContextID
	
}

/* Returns all browser contexts created with `Target.createBrowserContext` method. */
func (t *Tab) TargetGetBrowserContexts() (TargetGetBrowserContextsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.getBrowserContexts",
		"params": params_,
	})

	var returns_ TargetGetBrowserContextsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetCreateTargetReturns struct {
	
	TargetId TargetTargetID
	
}

/* Creates a new page. */
func (t *Tab) TargetCreateTarget(url string, width int, height int, browserContextId BrowserBrowserContextID, enableBeginFrameControl bool, newWindow bool, background bool) (TargetCreateTargetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["url"] = url
	
	
	
	if !isZero(width) {
		params_["width"] = width
	}
	
	
	
	if !isZero(height) {
		params_["height"] = height
	}
	
	
	
	if !isZero(browserContextId) {
		params_["browserContextId"] = browserContextId
	}
	
	
	
	if !isZero(enableBeginFrameControl) {
		params_["enableBeginFrameControl"] = enableBeginFrameControl
	}
	
	
	
	if !isZero(newWindow) {
		params_["newWindow"] = newWindow
	}
	
	
	
	if !isZero(background) {
		params_["background"] = background
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.createTarget",
		"params": params_,
	})

	var returns_ TargetCreateTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetDetachFromTargetReturns struct {
	
}

/* Detaches session with given id. */
func (t *Tab) TargetDetachFromTarget(sessionId TargetSessionID, targetId TargetTargetID) (TargetDetachFromTargetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(sessionId) {
		params_["sessionId"] = sessionId
	}
	
	
	
	if !isZero(targetId) {
		params_["targetId"] = targetId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.detachFromTarget",
		"params": params_,
	})

	var returns_ TargetDetachFromTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetDisposeBrowserContextReturns struct {
	
}

/* Deletes a BrowserContext. All the belonging pages will be closed without calling their
beforeunload hooks. */
func (t *Tab) TargetDisposeBrowserContext(browserContextId BrowserBrowserContextID) (TargetDisposeBrowserContextReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["browserContextId"] = browserContextId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.disposeBrowserContext",
		"params": params_,
	})

	var returns_ TargetDisposeBrowserContextReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetGetTargetInfoReturns struct {
	
	TargetInfo TargetTargetInfo
	
}

/* Returns information about a target. */
func (t *Tab) TargetGetTargetInfo(targetId TargetTargetID) (TargetGetTargetInfoReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(targetId) {
		params_["targetId"] = targetId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.getTargetInfo",
		"params": params_,
	})

	var returns_ TargetGetTargetInfoReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetGetTargetsReturns struct {
	
	TargetInfos []TargetTargetInfo
	
}

/* Retrieves a list of available targets. */
func (t *Tab) TargetGetTargets() (TargetGetTargetsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.getTargets",
		"params": params_,
	})

	var returns_ TargetGetTargetsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetSendMessageToTargetReturns struct {
	
}

/* Sends protocol message over session with given id.
Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
and crbug.com/991325. */
func (t *Tab) TargetSendMessageToTarget(message string, sessionId TargetSessionID, targetId TargetTargetID) (TargetSendMessageToTargetReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["message"] = message
	
	
	
	if !isZero(sessionId) {
		params_["sessionId"] = sessionId
	}
	
	
	
	if !isZero(targetId) {
		params_["targetId"] = targetId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.sendMessageToTarget",
		"params": params_,
	})

	var returns_ TargetSendMessageToTargetReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetSetAutoAttachReturns struct {
	
}

/* Controls whether to automatically attach to new targets which are considered to be related to
this one. When turned on, attaches to all existing related targets as well. When turned off,
automatically detaches from all currently attached targets. */
func (t *Tab) TargetSetAutoAttach(autoAttach bool, waitForDebuggerOnStart bool, flatten bool, windowOpen bool) (TargetSetAutoAttachReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["autoAttach"] = autoAttach
	
	
	
	params_["waitForDebuggerOnStart"] = waitForDebuggerOnStart
	
	
	
	if !isZero(flatten) {
		params_["flatten"] = flatten
	}
	
	
	
	if !isZero(windowOpen) {
		params_["windowOpen"] = windowOpen
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.setAutoAttach",
		"params": params_,
	})

	var returns_ TargetSetAutoAttachReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetSetDiscoverTargetsReturns struct {
	
}

/* Controls whether to discover available targets and notify via
`targetCreated/targetInfoChanged/targetDestroyed` events. */
func (t *Tab) TargetSetDiscoverTargets(discover bool) (TargetSetDiscoverTargetsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["discover"] = discover
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.setDiscoverTargets",
		"params": params_,
	})

	var returns_ TargetSetDiscoverTargetsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TargetSetRemoteLocationsReturns struct {
	
}

/* Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
`true`. */
func (t *Tab) TargetSetRemoteLocations(locations []TargetRemoteLocation) (TargetSetRemoteLocationsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["locations"] = locations
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Target.setRemoteLocations",
		"params": params_,
	})

	var returns_ TargetSetRemoteLocationsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TetheringBindReturns struct {
	
}

/* Request browser port binding. */
func (t *Tab) TetheringBind(port int) (TetheringBindReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["port"] = port
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Tethering.bind",
		"params": params_,
	})

	var returns_ TetheringBindReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TetheringUnbindReturns struct {
	
}

/* Request browser port unbinding. */
func (t *Tab) TetheringUnbind(port int) (TetheringUnbindReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["port"] = port
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Tethering.unbind",
		"params": params_,
	})

	var returns_ TetheringUnbindReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TracingEndReturns struct {
	
}

/* Stop trace events collection. */
func (t *Tab) TracingEnd() (TracingEndReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Tracing.end",
		"params": params_,
	})

	var returns_ TracingEndReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TracingGetCategoriesReturns struct {
	
	Categories []string
	
}

/* Gets supported tracing categories. */
func (t *Tab) TracingGetCategories() (TracingGetCategoriesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Tracing.getCategories",
		"params": params_,
	})

	var returns_ TracingGetCategoriesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TracingRecordClockSyncMarkerReturns struct {
	
}

/* Record a clock sync marker in the trace. */
func (t *Tab) TracingRecordClockSyncMarker(syncId string) (TracingRecordClockSyncMarkerReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["syncId"] = syncId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Tracing.recordClockSyncMarker",
		"params": params_,
	})

	var returns_ TracingRecordClockSyncMarkerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TracingRequestMemoryDumpReturns struct {
	
	DumpGuid string
	
	Success bool
	
}

/* Request a global memory dump. */
func (t *Tab) TracingRequestMemoryDump(deterministic bool) (TracingRequestMemoryDumpReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(deterministic) {
		params_["deterministic"] = deterministic
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Tracing.requestMemoryDump",
		"params": params_,
	})

	var returns_ TracingRequestMemoryDumpReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type TracingStartReturns struct {
	
}

/* Start trace events collection. */
func (t *Tab) TracingStart(categories string, options string, bufferUsageReportingInterval float64, transferMode string, streamFormat TracingStreamFormat, streamCompression TracingStreamCompression, traceConfig TracingTraceConfig) (TracingStartReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(categories) {
		params_["categories"] = categories
	}
	
	
	
	if !isZero(options) {
		params_["options"] = options
	}
	
	
	
	if !isZero(bufferUsageReportingInterval) {
		params_["bufferUsageReportingInterval"] = bufferUsageReportingInterval
	}
	
	
	
	if !isZero(transferMode) {
		params_["transferMode"] = transferMode
	}
	
	
	
	if !isZero(streamFormat) {
		params_["streamFormat"] = streamFormat
	}
	
	
	
	if !isZero(streamCompression) {
		params_["streamCompression"] = streamCompression
	}
	
	
	
	if !isZero(traceConfig) {
		params_["traceConfig"] = traceConfig
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Tracing.start",
		"params": params_,
	})

	var returns_ TracingStartReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchDisableReturns struct {
	
}

/* Disables the fetch domain. */
func (t *Tab) FetchDisable() (FetchDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.disable",
		"params": params_,
	})

	var returns_ FetchDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchEnableReturns struct {
	
}

/* Enables issuing of requestPaused events. A request will be paused until client
calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth. */
func (t *Tab) FetchEnable(patterns []FetchRequestPattern, handleAuthRequests bool) (FetchEnableReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(patterns) {
		params_["patterns"] = patterns
	}
	
	
	
	if !isZero(handleAuthRequests) {
		params_["handleAuthRequests"] = handleAuthRequests
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.enable",
		"params": params_,
	})

	var returns_ FetchEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchFailRequestReturns struct {
	
}

/* Causes the request to fail with specified reason. */
func (t *Tab) FetchFailRequest(requestId FetchRequestId, errorReason NetworkErrorReason) (FetchFailRequestReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	
	
	params_["errorReason"] = errorReason
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.failRequest",
		"params": params_,
	})

	var returns_ FetchFailRequestReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchFulfillRequestReturns struct {
	
}

/* Provides response to the request. */
func (t *Tab) FetchFulfillRequest(requestId FetchRequestId, responseCode int, responseHeaders []FetchHeaderEntry, binaryResponseHeaders []byte, body []byte, responsePhrase string) (FetchFulfillRequestReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	
	
	params_["responseCode"] = responseCode
	
	
	
	if !isZero(responseHeaders) {
		params_["responseHeaders"] = responseHeaders
	}
	
	
	
	if !isZero(binaryResponseHeaders) {
		params_["binaryResponseHeaders"] = binaryResponseHeaders
	}
	
	
	
	if !isZero(body) {
		params_["body"] = body
	}
	
	
	
	if !isZero(responsePhrase) {
		params_["responsePhrase"] = responsePhrase
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.fulfillRequest",
		"params": params_,
	})

	var returns_ FetchFulfillRequestReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchContinueRequestReturns struct {
	
}

/* Continues the request, optionally modifying some of its parameters. */
func (t *Tab) FetchContinueRequest(requestId FetchRequestId, url string, method string, postData string, headers []FetchHeaderEntry) (FetchContinueRequestReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	
	
	if !isZero(url) {
		params_["url"] = url
	}
	
	
	
	if !isZero(method) {
		params_["method"] = method
	}
	
	
	
	if !isZero(postData) {
		params_["postData"] = postData
	}
	
	
	
	if !isZero(headers) {
		params_["headers"] = headers
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.continueRequest",
		"params": params_,
	})

	var returns_ FetchContinueRequestReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchContinueWithAuthReturns struct {
	
}

/* Continues a request supplying authChallengeResponse following authRequired event. */
func (t *Tab) FetchContinueWithAuth(requestId FetchRequestId, authChallengeResponse FetchAuthChallengeResponse) (FetchContinueWithAuthReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	
	
	params_["authChallengeResponse"] = authChallengeResponse
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.continueWithAuth",
		"params": params_,
	})

	var returns_ FetchContinueWithAuthReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchGetResponseBodyReturns struct {
	
	Body string
	
	Base64Encoded bool
	
}

/* Causes the body of the response to be received from the server and
returned as a single string. May only be issued for a request that
is paused in the Response stage and is mutually exclusive with
takeResponseBodyForInterceptionAsStream. Calling other methods that
affect the request or disabling fetch domain before body is received
results in an undefined behavior. */
func (t *Tab) FetchGetResponseBody(requestId FetchRequestId) (FetchGetResponseBodyReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.getResponseBody",
		"params": params_,
	})

	var returns_ FetchGetResponseBodyReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type FetchTakeResponseBodyAsStreamReturns struct {
	
	Stream IOStreamHandle
	
}

/* Returns a handle to the stream representing the response body.
The request must be paused in the HeadersReceived stage.
Note that after this command the request can't be continued
as is -- client either needs to cancel it or to provide the
response body.
The stream only supports sequential read, IO.read will fail if the position
is specified.
This method is mutually exclusive with getResponseBody.
Calling other methods that affect the request or disabling fetch
domain before body is received results in an undefined behavior. */
func (t *Tab) FetchTakeResponseBodyAsStream(requestId FetchRequestId) (FetchTakeResponseBodyAsStreamReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["requestId"] = requestId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Fetch.takeResponseBodyAsStream",
		"params": params_,
	})

	var returns_ FetchTakeResponseBodyAsStreamReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAudioEnableReturns struct {
	
}

/* Enables the WebAudio domain and starts sending context lifetime events. */
func (t *Tab) WebAudioEnable() (WebAudioEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAudio.enable",
		"params": params_,
	})

	var returns_ WebAudioEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAudioDisableReturns struct {
	
}

/* Disables the WebAudio domain. */
func (t *Tab) WebAudioDisable() (WebAudioDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAudio.disable",
		"params": params_,
	})

	var returns_ WebAudioDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAudioGetRealtimeDataReturns struct {
	
	RealtimeData WebAudioContextRealtimeData
	
}

/* Fetch the realtime data from the registered contexts. */
func (t *Tab) WebAudioGetRealtimeData(contextId WebAudioGraphObjectId) (WebAudioGetRealtimeDataReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["contextId"] = contextId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAudio.getRealtimeData",
		"params": params_,
	})

	var returns_ WebAudioGetRealtimeDataReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnEnableReturns struct {
	
}

/* Enable the WebAuthn domain and start intercepting credential storage and
retrieval with a virtual authenticator. */
func (t *Tab) WebAuthnEnable() (WebAuthnEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.enable",
		"params": params_,
	})

	var returns_ WebAuthnEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnDisableReturns struct {
	
}

/* Disable the WebAuthn domain. */
func (t *Tab) WebAuthnDisable() (WebAuthnDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.disable",
		"params": params_,
	})

	var returns_ WebAuthnDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnAddVirtualAuthenticatorReturns struct {
	
	AuthenticatorId WebAuthnAuthenticatorId
	
}

/* Creates and adds a virtual authenticator. */
func (t *Tab) WebAuthnAddVirtualAuthenticator(options WebAuthnVirtualAuthenticatorOptions) (WebAuthnAddVirtualAuthenticatorReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["options"] = options
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.addVirtualAuthenticator",
		"params": params_,
	})

	var returns_ WebAuthnAddVirtualAuthenticatorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnRemoveVirtualAuthenticatorReturns struct {
	
}

/* Removes the given authenticator. */
func (t *Tab) WebAuthnRemoveVirtualAuthenticator(authenticatorId WebAuthnAuthenticatorId) (WebAuthnRemoveVirtualAuthenticatorReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["authenticatorId"] = authenticatorId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.removeVirtualAuthenticator",
		"params": params_,
	})

	var returns_ WebAuthnRemoveVirtualAuthenticatorReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnAddCredentialReturns struct {
	
}

/* Adds the credential to the specified authenticator. */
func (t *Tab) WebAuthnAddCredential(authenticatorId WebAuthnAuthenticatorId, credential WebAuthnCredential) (WebAuthnAddCredentialReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["authenticatorId"] = authenticatorId
	
	
	
	params_["credential"] = credential
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.addCredential",
		"params": params_,
	})

	var returns_ WebAuthnAddCredentialReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnGetCredentialReturns struct {
	
	Credential WebAuthnCredential
	
}

/* Returns a single credential stored in the given virtual authenticator that
matches the credential ID. */
func (t *Tab) WebAuthnGetCredential(authenticatorId WebAuthnAuthenticatorId, credentialId []byte) (WebAuthnGetCredentialReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["authenticatorId"] = authenticatorId
	
	
	
	params_["credentialId"] = credentialId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.getCredential",
		"params": params_,
	})

	var returns_ WebAuthnGetCredentialReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnGetCredentialsReturns struct {
	
	Credentials []WebAuthnCredential
	
}

/* Returns all the credentials stored in the given virtual authenticator. */
func (t *Tab) WebAuthnGetCredentials(authenticatorId WebAuthnAuthenticatorId) (WebAuthnGetCredentialsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["authenticatorId"] = authenticatorId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.getCredentials",
		"params": params_,
	})

	var returns_ WebAuthnGetCredentialsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnRemoveCredentialReturns struct {
	
}

/* Removes a credential from the authenticator. */
func (t *Tab) WebAuthnRemoveCredential(authenticatorId WebAuthnAuthenticatorId, credentialId []byte) (WebAuthnRemoveCredentialReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["authenticatorId"] = authenticatorId
	
	
	
	params_["credentialId"] = credentialId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.removeCredential",
		"params": params_,
	})

	var returns_ WebAuthnRemoveCredentialReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnClearCredentialsReturns struct {
	
}

/* Clears all the credentials from the specified device. */
func (t *Tab) WebAuthnClearCredentials(authenticatorId WebAuthnAuthenticatorId) (WebAuthnClearCredentialsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["authenticatorId"] = authenticatorId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.clearCredentials",
		"params": params_,
	})

	var returns_ WebAuthnClearCredentialsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type WebAuthnSetUserVerifiedReturns struct {
	
}

/* Sets whether User Verification succeeds or fails for an authenticator.
The default is true. */
func (t *Tab) WebAuthnSetUserVerified(authenticatorId WebAuthnAuthenticatorId, isUserVerified bool) (WebAuthnSetUserVerifiedReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["authenticatorId"] = authenticatorId
	
	
	
	params_["isUserVerified"] = isUserVerified
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "WebAuthn.setUserVerified",
		"params": params_,
	})

	var returns_ WebAuthnSetUserVerifiedReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MediaEnableReturns struct {
	
}

/* Enables the Media domain */
func (t *Tab) MediaEnable() (MediaEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Media.enable",
		"params": params_,
	})

	var returns_ MediaEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type MediaDisableReturns struct {
	
}

/* Disables the Media domain. */
func (t *Tab) MediaDisable() (MediaDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Media.disable",
		"params": params_,
	})

	var returns_ MediaDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ConsoleClearMessagesReturns struct {
	
}

/* Does nothing. */
func (t *Tab) ConsoleClearMessages() (ConsoleClearMessagesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Console.clearMessages",
		"params": params_,
	})

	var returns_ ConsoleClearMessagesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ConsoleDisableReturns struct {
	
}

/* Disables console domain, prevents further console messages from being reported to the client. */
func (t *Tab) ConsoleDisable() (ConsoleDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Console.disable",
		"params": params_,
	})

	var returns_ ConsoleDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ConsoleEnableReturns struct {
	
}

/* Enables console domain, sends the messages collected so far to the client by means of the
`messageAdded` notification. */
func (t *Tab) ConsoleEnable() (ConsoleEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Console.enable",
		"params": params_,
	})

	var returns_ ConsoleEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerContinueToLocationReturns struct {
	
}

/* Continues execution until specific location is reached. */
func (t *Tab) DebuggerContinueToLocation(location DebuggerLocation, targetCallFrames string) (DebuggerContinueToLocationReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["location"] = location
	
	
	
	if !isZero(targetCallFrames) {
		params_["targetCallFrames"] = targetCallFrames
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.continueToLocation",
		"params": params_,
	})

	var returns_ DebuggerContinueToLocationReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerDisableReturns struct {
	
}

/* Disables debugger for given page. */
func (t *Tab) DebuggerDisable() (DebuggerDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.disable",
		"params": params_,
	})

	var returns_ DebuggerDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerEnableReturns struct {
	
	DebuggerId RuntimeUniqueDebuggerId
	
}

/* Enables debugger for the given page. Clients should not assume that the debugging has been
enabled until the result for this command is received. */
func (t *Tab) DebuggerEnable(maxScriptsCacheSize float64) (DebuggerEnableReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(maxScriptsCacheSize) {
		params_["maxScriptsCacheSize"] = maxScriptsCacheSize
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.enable",
		"params": params_,
	})

	var returns_ DebuggerEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerEvaluateOnCallFrameReturns struct {
	
	Result RuntimeRemoteObject
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Evaluates expression on a given call frame. */
func (t *Tab) DebuggerEvaluateOnCallFrame(callFrameId DebuggerCallFrameId, expression string, objectGroup string, includeCommandLineAPI bool, silent bool, returnByValue bool, generatePreview bool, throwOnSideEffect bool, timeout RuntimeTimeDelta) (DebuggerEvaluateOnCallFrameReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["callFrameId"] = callFrameId
	
	
	
	params_["expression"] = expression
	
	
	
	if !isZero(objectGroup) {
		params_["objectGroup"] = objectGroup
	}
	
	
	
	if !isZero(includeCommandLineAPI) {
		params_["includeCommandLineAPI"] = includeCommandLineAPI
	}
	
	
	
	if !isZero(silent) {
		params_["silent"] = silent
	}
	
	
	
	if !isZero(returnByValue) {
		params_["returnByValue"] = returnByValue
	}
	
	
	
	if !isZero(generatePreview) {
		params_["generatePreview"] = generatePreview
	}
	
	
	
	if !isZero(throwOnSideEffect) {
		params_["throwOnSideEffect"] = throwOnSideEffect
	}
	
	
	
	if !isZero(timeout) {
		params_["timeout"] = timeout
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.evaluateOnCallFrame",
		"params": params_,
	})

	var returns_ DebuggerEvaluateOnCallFrameReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerGetPossibleBreakpointsReturns struct {
	
	Locations []DebuggerBreakLocation
	
}

/* Returns possible locations for breakpoint. scriptId in start and end range locations should be
the same. */
func (t *Tab) DebuggerGetPossibleBreakpoints(start DebuggerLocation, end DebuggerLocation, restrictToFunction bool) (DebuggerGetPossibleBreakpointsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["start"] = start
	
	
	
	if !isZero(end) {
		params_["end"] = end
	}
	
	
	
	if !isZero(restrictToFunction) {
		params_["restrictToFunction"] = restrictToFunction
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.getPossibleBreakpoints",
		"params": params_,
	})

	var returns_ DebuggerGetPossibleBreakpointsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerGetScriptSourceReturns struct {
	
	ScriptSource string
	
	Bytecode []byte
	
}

/* Returns source for the script with given id. */
func (t *Tab) DebuggerGetScriptSource(scriptId RuntimeScriptId) (DebuggerGetScriptSourceReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scriptId"] = scriptId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.getScriptSource",
		"params": params_,
	})

	var returns_ DebuggerGetScriptSourceReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerGetWasmBytecodeReturns struct {
	
	Bytecode []byte
	
}

/* This command is deprecated. Use getScriptSource instead. */
func (t *Tab) DebuggerGetWasmBytecode(scriptId RuntimeScriptId) (DebuggerGetWasmBytecodeReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scriptId"] = scriptId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.getWasmBytecode",
		"params": params_,
	})

	var returns_ DebuggerGetWasmBytecodeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerGetStackTraceReturns struct {
	
	StackTrace RuntimeStackTrace
	
}

/* Returns stack trace with given `stackTraceId`. */
func (t *Tab) DebuggerGetStackTrace(stackTraceId RuntimeStackTraceId) (DebuggerGetStackTraceReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["stackTraceId"] = stackTraceId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.getStackTrace",
		"params": params_,
	})

	var returns_ DebuggerGetStackTraceReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerPauseReturns struct {
	
}

/* Stops on the next JavaScript statement. */
func (t *Tab) DebuggerPause() (DebuggerPauseReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.pause",
		"params": params_,
	})

	var returns_ DebuggerPauseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerPauseOnAsyncCallReturns struct {
	
}

/*  */
func (t *Tab) DebuggerPauseOnAsyncCall(parentStackTraceId RuntimeStackTraceId) (DebuggerPauseOnAsyncCallReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["parentStackTraceId"] = parentStackTraceId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.pauseOnAsyncCall",
		"params": params_,
	})

	var returns_ DebuggerPauseOnAsyncCallReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerRemoveBreakpointReturns struct {
	
}

/* Removes JavaScript breakpoint. */
func (t *Tab) DebuggerRemoveBreakpoint(breakpointId DebuggerBreakpointId) (DebuggerRemoveBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["breakpointId"] = breakpointId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.removeBreakpoint",
		"params": params_,
	})

	var returns_ DebuggerRemoveBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerRestartFrameReturns struct {
	
	CallFrames []DebuggerCallFrame
	
	AsyncStackTrace RuntimeStackTrace
	
	AsyncStackTraceId RuntimeStackTraceId
	
}

/* Restarts particular call frame from the beginning. */
func (t *Tab) DebuggerRestartFrame(callFrameId DebuggerCallFrameId) (DebuggerRestartFrameReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["callFrameId"] = callFrameId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.restartFrame",
		"params": params_,
	})

	var returns_ DebuggerRestartFrameReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerResumeReturns struct {
	
}

/* Resumes JavaScript execution. */
func (t *Tab) DebuggerResume() (DebuggerResumeReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.resume",
		"params": params_,
	})

	var returns_ DebuggerResumeReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSearchInContentReturns struct {
	
	Result []DebuggerSearchMatch
	
}

/* Searches for given string in script content. */
func (t *Tab) DebuggerSearchInContent(scriptId RuntimeScriptId, query string, caseSensitive bool, isRegex bool) (DebuggerSearchInContentReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scriptId"] = scriptId
	
	
	
	params_["query"] = query
	
	
	
	if !isZero(caseSensitive) {
		params_["caseSensitive"] = caseSensitive
	}
	
	
	
	if !isZero(isRegex) {
		params_["isRegex"] = isRegex
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.searchInContent",
		"params": params_,
	})

	var returns_ DebuggerSearchInContentReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetAsyncCallStackDepthReturns struct {
	
}

/* Enables or disables async call stacks tracking. */
func (t *Tab) DebuggerSetAsyncCallStackDepth(maxDepth int) (DebuggerSetAsyncCallStackDepthReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["maxDepth"] = maxDepth
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setAsyncCallStackDepth",
		"params": params_,
	})

	var returns_ DebuggerSetAsyncCallStackDepthReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetBlackboxPatternsReturns struct {
	
}

/* Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
scripts with url matching one of the patterns. VM will try to leave blackboxed script by
performing 'step in' several times, finally resorting to 'step out' if unsuccessful. */
func (t *Tab) DebuggerSetBlackboxPatterns(patterns []string) (DebuggerSetBlackboxPatternsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["patterns"] = patterns
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setBlackboxPatterns",
		"params": params_,
	})

	var returns_ DebuggerSetBlackboxPatternsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetBlackboxedRangesReturns struct {
	
}

/* Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
Positions array contains positions where blackbox state is changed. First interval isn't
blackboxed. Array should be sorted. */
func (t *Tab) DebuggerSetBlackboxedRanges(scriptId RuntimeScriptId, positions []DebuggerScriptPosition) (DebuggerSetBlackboxedRangesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scriptId"] = scriptId
	
	
	
	params_["positions"] = positions
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setBlackboxedRanges",
		"params": params_,
	})

	var returns_ DebuggerSetBlackboxedRangesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetBreakpointReturns struct {
	
	BreakpointId DebuggerBreakpointId
	
	ActualLocation DebuggerLocation
	
}

/* Sets JavaScript breakpoint at a given location. */
func (t *Tab) DebuggerSetBreakpoint(location DebuggerLocation, condition string) (DebuggerSetBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["location"] = location
	
	
	
	if !isZero(condition) {
		params_["condition"] = condition
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setBreakpoint",
		"params": params_,
	})

	var returns_ DebuggerSetBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetInstrumentationBreakpointReturns struct {
	
	BreakpointId DebuggerBreakpointId
	
}

/* Sets instrumentation breakpoint. */
func (t *Tab) DebuggerSetInstrumentationBreakpoint(instrumentation string) (DebuggerSetInstrumentationBreakpointReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["instrumentation"] = instrumentation
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setInstrumentationBreakpoint",
		"params": params_,
	})

	var returns_ DebuggerSetInstrumentationBreakpointReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetBreakpointByUrlReturns struct {
	
	BreakpointId DebuggerBreakpointId
	
	Locations []DebuggerLocation
	
}

/* Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
command is issued, all existing parsed scripts will have breakpoints resolved and returned in
`locations` property. Further matching script parsing will result in subsequent
`breakpointResolved` events issued. This logical breakpoint will survive page reloads. */
func (t *Tab) DebuggerSetBreakpointByUrl(lineNumber int, url string, urlRegex string, scriptHash string, columnNumber int, condition string) (DebuggerSetBreakpointByUrlReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["lineNumber"] = lineNumber
	
	
	
	if !isZero(url) {
		params_["url"] = url
	}
	
	
	
	if !isZero(urlRegex) {
		params_["urlRegex"] = urlRegex
	}
	
	
	
	if !isZero(scriptHash) {
		params_["scriptHash"] = scriptHash
	}
	
	
	
	if !isZero(columnNumber) {
		params_["columnNumber"] = columnNumber
	}
	
	
	
	if !isZero(condition) {
		params_["condition"] = condition
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setBreakpointByUrl",
		"params": params_,
	})

	var returns_ DebuggerSetBreakpointByUrlReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetBreakpointOnFunctionCallReturns struct {
	
	BreakpointId DebuggerBreakpointId
	
}

/* Sets JavaScript breakpoint before each call to the given function.
If another function was created from the same source as a given one,
calling it will also trigger the breakpoint. */
func (t *Tab) DebuggerSetBreakpointOnFunctionCall(objectId RuntimeRemoteObjectId, condition string) (DebuggerSetBreakpointOnFunctionCallReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	
	
	if !isZero(condition) {
		params_["condition"] = condition
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setBreakpointOnFunctionCall",
		"params": params_,
	})

	var returns_ DebuggerSetBreakpointOnFunctionCallReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetBreakpointsActiveReturns struct {
	
}

/* Activates / deactivates all breakpoints on the page. */
func (t *Tab) DebuggerSetBreakpointsActive(active bool) (DebuggerSetBreakpointsActiveReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["active"] = active
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setBreakpointsActive",
		"params": params_,
	})

	var returns_ DebuggerSetBreakpointsActiveReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetPauseOnExceptionsReturns struct {
	
}

/* Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
no exceptions. Initial pause on exceptions state is `none`. */
func (t *Tab) DebuggerSetPauseOnExceptions(state string) (DebuggerSetPauseOnExceptionsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["state"] = state
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setPauseOnExceptions",
		"params": params_,
	})

	var returns_ DebuggerSetPauseOnExceptionsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetReturnValueReturns struct {
	
}

/* Changes return value in top frame. Available only at return break position. */
func (t *Tab) DebuggerSetReturnValue(newValue RuntimeCallArgument) (DebuggerSetReturnValueReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["newValue"] = newValue
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setReturnValue",
		"params": params_,
	})

	var returns_ DebuggerSetReturnValueReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetScriptSourceReturns struct {
	
	CallFrames []DebuggerCallFrame
	
	StackChanged bool
	
	AsyncStackTrace RuntimeStackTrace
	
	AsyncStackTraceId RuntimeStackTraceId
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Edits JavaScript source live. */
func (t *Tab) DebuggerSetScriptSource(scriptId RuntimeScriptId, scriptSource string, dryRun bool) (DebuggerSetScriptSourceReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scriptId"] = scriptId
	
	
	
	params_["scriptSource"] = scriptSource
	
	
	
	if !isZero(dryRun) {
		params_["dryRun"] = dryRun
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setScriptSource",
		"params": params_,
	})

	var returns_ DebuggerSetScriptSourceReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetSkipAllPausesReturns struct {
	
}

/* Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). */
func (t *Tab) DebuggerSetSkipAllPauses(skip bool) (DebuggerSetSkipAllPausesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["skip"] = skip
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setSkipAllPauses",
		"params": params_,
	})

	var returns_ DebuggerSetSkipAllPausesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerSetVariableValueReturns struct {
	
}

/* Changes value of variable in a callframe. Object-based scopes are not supported and must be
mutated manually. */
func (t *Tab) DebuggerSetVariableValue(scopeNumber int, variableName string, newValue RuntimeCallArgument, callFrameId DebuggerCallFrameId) (DebuggerSetVariableValueReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scopeNumber"] = scopeNumber
	
	
	
	params_["variableName"] = variableName
	
	
	
	params_["newValue"] = newValue
	
	
	
	params_["callFrameId"] = callFrameId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.setVariableValue",
		"params": params_,
	})

	var returns_ DebuggerSetVariableValueReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerStepIntoReturns struct {
	
}

/* Steps into the function call. */
func (t *Tab) DebuggerStepInto(breakOnAsyncCall bool) (DebuggerStepIntoReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(breakOnAsyncCall) {
		params_["breakOnAsyncCall"] = breakOnAsyncCall
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.stepInto",
		"params": params_,
	})

	var returns_ DebuggerStepIntoReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerStepOutReturns struct {
	
}

/* Steps out of the function call. */
func (t *Tab) DebuggerStepOut() (DebuggerStepOutReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.stepOut",
		"params": params_,
	})

	var returns_ DebuggerStepOutReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type DebuggerStepOverReturns struct {
	
}

/* Steps over the statement. */
func (t *Tab) DebuggerStepOver() (DebuggerStepOverReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Debugger.stepOver",
		"params": params_,
	})

	var returns_ DebuggerStepOverReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerAddInspectedHeapObjectReturns struct {
	
}

/* Enables console to refer to the node with given id via $x (see Command Line API for more details
$x functions). */
func (t *Tab) HeapProfilerAddInspectedHeapObject(heapObjectId HeapProfilerHeapSnapshotObjectId) (HeapProfilerAddInspectedHeapObjectReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["heapObjectId"] = heapObjectId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.addInspectedHeapObject",
		"params": params_,
	})

	var returns_ HeapProfilerAddInspectedHeapObjectReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerCollectGarbageReturns struct {
	
}

/*  */
func (t *Tab) HeapProfilerCollectGarbage() (HeapProfilerCollectGarbageReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.collectGarbage",
		"params": params_,
	})

	var returns_ HeapProfilerCollectGarbageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerDisableReturns struct {
	
}

/*  */
func (t *Tab) HeapProfilerDisable() (HeapProfilerDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.disable",
		"params": params_,
	})

	var returns_ HeapProfilerDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerEnableReturns struct {
	
}

/*  */
func (t *Tab) HeapProfilerEnable() (HeapProfilerEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.enable",
		"params": params_,
	})

	var returns_ HeapProfilerEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerGetHeapObjectIdReturns struct {
	
	HeapSnapshotObjectId HeapProfilerHeapSnapshotObjectId
	
}

/*  */
func (t *Tab) HeapProfilerGetHeapObjectId(objectId RuntimeRemoteObjectId) (HeapProfilerGetHeapObjectIdReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.getHeapObjectId",
		"params": params_,
	})

	var returns_ HeapProfilerGetHeapObjectIdReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerGetObjectByHeapObjectIdReturns struct {
	
	Result RuntimeRemoteObject
	
}

/*  */
func (t *Tab) HeapProfilerGetObjectByHeapObjectId(objectId HeapProfilerHeapSnapshotObjectId, objectGroup string) (HeapProfilerGetObjectByHeapObjectIdReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	
	
	if !isZero(objectGroup) {
		params_["objectGroup"] = objectGroup
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.getObjectByHeapObjectId",
		"params": params_,
	})

	var returns_ HeapProfilerGetObjectByHeapObjectIdReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerGetSamplingProfileReturns struct {
	
	Profile HeapProfilerSamplingHeapProfile
	
}

/*  */
func (t *Tab) HeapProfilerGetSamplingProfile() (HeapProfilerGetSamplingProfileReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.getSamplingProfile",
		"params": params_,
	})

	var returns_ HeapProfilerGetSamplingProfileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerStartSamplingReturns struct {
	
}

/*  */
func (t *Tab) HeapProfilerStartSampling(samplingInterval float64) (HeapProfilerStartSamplingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(samplingInterval) {
		params_["samplingInterval"] = samplingInterval
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.startSampling",
		"params": params_,
	})

	var returns_ HeapProfilerStartSamplingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerStartTrackingHeapObjectsReturns struct {
	
}

/*  */
func (t *Tab) HeapProfilerStartTrackingHeapObjects(trackAllocations bool) (HeapProfilerStartTrackingHeapObjectsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(trackAllocations) {
		params_["trackAllocations"] = trackAllocations
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.startTrackingHeapObjects",
		"params": params_,
	})

	var returns_ HeapProfilerStartTrackingHeapObjectsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerStopSamplingReturns struct {
	
	Profile HeapProfilerSamplingHeapProfile
	
}

/*  */
func (t *Tab) HeapProfilerStopSampling() (HeapProfilerStopSamplingReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.stopSampling",
		"params": params_,
	})

	var returns_ HeapProfilerStopSamplingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerStopTrackingHeapObjectsReturns struct {
	
}

/*  */
func (t *Tab) HeapProfilerStopTrackingHeapObjects(reportProgress bool) (HeapProfilerStopTrackingHeapObjectsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(reportProgress) {
		params_["reportProgress"] = reportProgress
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.stopTrackingHeapObjects",
		"params": params_,
	})

	var returns_ HeapProfilerStopTrackingHeapObjectsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type HeapProfilerTakeHeapSnapshotReturns struct {
	
}

/*  */
func (t *Tab) HeapProfilerTakeHeapSnapshot(reportProgress bool) (HeapProfilerTakeHeapSnapshotReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(reportProgress) {
		params_["reportProgress"] = reportProgress
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "HeapProfiler.takeHeapSnapshot",
		"params": params_,
	})

	var returns_ HeapProfilerTakeHeapSnapshotReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerDisableReturns struct {
	
}

/*  */
func (t *Tab) ProfilerDisable() (ProfilerDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.disable",
		"params": params_,
	})

	var returns_ ProfilerDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerEnableReturns struct {
	
}

/*  */
func (t *Tab) ProfilerEnable() (ProfilerEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.enable",
		"params": params_,
	})

	var returns_ ProfilerEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerGetBestEffortCoverageReturns struct {
	
	Result []ProfilerScriptCoverage
	
}

/* Collect coverage data for the current isolate. The coverage data may be incomplete due to
garbage collection. */
func (t *Tab) ProfilerGetBestEffortCoverage() (ProfilerGetBestEffortCoverageReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.getBestEffortCoverage",
		"params": params_,
	})

	var returns_ ProfilerGetBestEffortCoverageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerSetSamplingIntervalReturns struct {
	
}

/* Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. */
func (t *Tab) ProfilerSetSamplingInterval(interval int) (ProfilerSetSamplingIntervalReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["interval"] = interval
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.setSamplingInterval",
		"params": params_,
	})

	var returns_ ProfilerSetSamplingIntervalReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerStartReturns struct {
	
}

/*  */
func (t *Tab) ProfilerStart() (ProfilerStartReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.start",
		"params": params_,
	})

	var returns_ ProfilerStartReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerStartPreciseCoverageReturns struct {
	
}

/* Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
coverage may be incomplete. Enabling prevents running optimized code and resets execution
counters. */
func (t *Tab) ProfilerStartPreciseCoverage(callCount bool, detailed bool) (ProfilerStartPreciseCoverageReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(callCount) {
		params_["callCount"] = callCount
	}
	
	
	
	if !isZero(detailed) {
		params_["detailed"] = detailed
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.startPreciseCoverage",
		"params": params_,
	})

	var returns_ ProfilerStartPreciseCoverageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerStartTypeProfileReturns struct {
	
}

/* Enable type profile. */
func (t *Tab) ProfilerStartTypeProfile() (ProfilerStartTypeProfileReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.startTypeProfile",
		"params": params_,
	})

	var returns_ ProfilerStartTypeProfileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerStopReturns struct {
	
	Profile ProfilerProfile
	
}

/*  */
func (t *Tab) ProfilerStop() (ProfilerStopReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.stop",
		"params": params_,
	})

	var returns_ ProfilerStopReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerStopPreciseCoverageReturns struct {
	
}

/* Disable precise code coverage. Disabling releases unnecessary execution count records and allows
executing optimized code. */
func (t *Tab) ProfilerStopPreciseCoverage() (ProfilerStopPreciseCoverageReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.stopPreciseCoverage",
		"params": params_,
	})

	var returns_ ProfilerStopPreciseCoverageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerStopTypeProfileReturns struct {
	
}

/* Disable type profile. Disabling releases type profile data collected so far. */
func (t *Tab) ProfilerStopTypeProfile() (ProfilerStopTypeProfileReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.stopTypeProfile",
		"params": params_,
	})

	var returns_ ProfilerStopTypeProfileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerTakePreciseCoverageReturns struct {
	
	Result []ProfilerScriptCoverage
	
}

/* Collect coverage data for the current isolate, and resets execution counters. Precise code
coverage needs to have started. */
func (t *Tab) ProfilerTakePreciseCoverage() (ProfilerTakePreciseCoverageReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.takePreciseCoverage",
		"params": params_,
	})

	var returns_ ProfilerTakePreciseCoverageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerTakeTypeProfileReturns struct {
	
	Result []ProfilerScriptTypeProfile
	
}

/* Collect type profile. */
func (t *Tab) ProfilerTakeTypeProfile() (ProfilerTakeTypeProfileReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.takeTypeProfile",
		"params": params_,
	})

	var returns_ ProfilerTakeTypeProfileReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerEnableRuntimeCallStatsReturns struct {
	
}

/* Enable run time call stats collection. */
func (t *Tab) ProfilerEnableRuntimeCallStats() (ProfilerEnableRuntimeCallStatsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.enableRuntimeCallStats",
		"params": params_,
	})

	var returns_ ProfilerEnableRuntimeCallStatsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerDisableRuntimeCallStatsReturns struct {
	
}

/* Disable run time call stats collection. */
func (t *Tab) ProfilerDisableRuntimeCallStats() (ProfilerDisableRuntimeCallStatsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.disableRuntimeCallStats",
		"params": params_,
	})

	var returns_ ProfilerDisableRuntimeCallStatsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type ProfilerGetRuntimeCallStatsReturns struct {
	
	Result []ProfilerCounterInfo
	
}

/* Retrieve run time call stats. */
func (t *Tab) ProfilerGetRuntimeCallStats() (ProfilerGetRuntimeCallStatsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Profiler.getRuntimeCallStats",
		"params": params_,
	})

	var returns_ ProfilerGetRuntimeCallStatsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeAwaitPromiseReturns struct {
	
	Result RuntimeRemoteObject
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Add handler to promise with given promise object id. */
func (t *Tab) RuntimeAwaitPromise(promiseObjectId RuntimeRemoteObjectId, returnByValue bool, generatePreview bool) (RuntimeAwaitPromiseReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["promiseObjectId"] = promiseObjectId
	
	
	
	if !isZero(returnByValue) {
		params_["returnByValue"] = returnByValue
	}
	
	
	
	if !isZero(generatePreview) {
		params_["generatePreview"] = generatePreview
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.awaitPromise",
		"params": params_,
	})

	var returns_ RuntimeAwaitPromiseReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeCallFunctionOnReturns struct {
	
	Result RuntimeRemoteObject
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Calls function with given declaration on the given object. Object group of the result is
inherited from the target object. */
func (t *Tab) RuntimeCallFunctionOn(functionDeclaration string, objectId RuntimeRemoteObjectId, arguments []RuntimeCallArgument, silent bool, returnByValue bool, generatePreview bool, userGesture bool, awaitPromise bool, executionContextId RuntimeExecutionContextId, objectGroup string) (RuntimeCallFunctionOnReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["functionDeclaration"] = functionDeclaration
	
	
	
	if !isZero(objectId) {
		params_["objectId"] = objectId
	}
	
	
	
	if !isZero(arguments) {
		params_["arguments"] = arguments
	}
	
	
	
	if !isZero(silent) {
		params_["silent"] = silent
	}
	
	
	
	if !isZero(returnByValue) {
		params_["returnByValue"] = returnByValue
	}
	
	
	
	if !isZero(generatePreview) {
		params_["generatePreview"] = generatePreview
	}
	
	
	
	if !isZero(userGesture) {
		params_["userGesture"] = userGesture
	}
	
	
	
	if !isZero(awaitPromise) {
		params_["awaitPromise"] = awaitPromise
	}
	
	
	
	if !isZero(executionContextId) {
		params_["executionContextId"] = executionContextId
	}
	
	
	
	if !isZero(objectGroup) {
		params_["objectGroup"] = objectGroup
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.callFunctionOn",
		"params": params_,
	})

	var returns_ RuntimeCallFunctionOnReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeCompileScriptReturns struct {
	
	ScriptId RuntimeScriptId
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Compiles expression. */
func (t *Tab) RuntimeCompileScript(expression string, sourceURL string, persistScript bool, executionContextId RuntimeExecutionContextId) (RuntimeCompileScriptReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["expression"] = expression
	
	
	
	params_["sourceURL"] = sourceURL
	
	
	
	params_["persistScript"] = persistScript
	
	
	
	if !isZero(executionContextId) {
		params_["executionContextId"] = executionContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.compileScript",
		"params": params_,
	})

	var returns_ RuntimeCompileScriptReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeDisableReturns struct {
	
}

/* Disables reporting of execution contexts creation. */
func (t *Tab) RuntimeDisable() (RuntimeDisableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.disable",
		"params": params_,
	})

	var returns_ RuntimeDisableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeDiscardConsoleEntriesReturns struct {
	
}

/* Discards collected exceptions and console API calls. */
func (t *Tab) RuntimeDiscardConsoleEntries() (RuntimeDiscardConsoleEntriesReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.discardConsoleEntries",
		"params": params_,
	})

	var returns_ RuntimeDiscardConsoleEntriesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeEnableReturns struct {
	
}

/* Enables reporting of execution contexts creation by means of `executionContextCreated` event.
When the reporting gets enabled the event will be sent immediately for each existing execution
context. */
func (t *Tab) RuntimeEnable() (RuntimeEnableReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.enable",
		"params": params_,
	})

	var returns_ RuntimeEnableReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeEvaluateReturns struct {
	
	Result RuntimeRemoteObject
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Evaluates expression on global object. */
func (t *Tab) RuntimeEvaluate(expression string, objectGroup string, includeCommandLineAPI bool, silent bool, contextId RuntimeExecutionContextId, returnByValue bool, generatePreview bool, userGesture bool, awaitPromise bool, throwOnSideEffect bool, timeout RuntimeTimeDelta, disableBreaks bool, replMode bool) (RuntimeEvaluateReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["expression"] = expression
	
	
	
	if !isZero(objectGroup) {
		params_["objectGroup"] = objectGroup
	}
	
	
	
	if !isZero(includeCommandLineAPI) {
		params_["includeCommandLineAPI"] = includeCommandLineAPI
	}
	
	
	
	if !isZero(silent) {
		params_["silent"] = silent
	}
	
	
	
	if !isZero(contextId) {
		params_["contextId"] = contextId
	}
	
	
	
	if !isZero(returnByValue) {
		params_["returnByValue"] = returnByValue
	}
	
	
	
	if !isZero(generatePreview) {
		params_["generatePreview"] = generatePreview
	}
	
	
	
	if !isZero(userGesture) {
		params_["userGesture"] = userGesture
	}
	
	
	
	if !isZero(awaitPromise) {
		params_["awaitPromise"] = awaitPromise
	}
	
	
	
	if !isZero(throwOnSideEffect) {
		params_["throwOnSideEffect"] = throwOnSideEffect
	}
	
	
	
	if !isZero(timeout) {
		params_["timeout"] = timeout
	}
	
	
	
	if !isZero(disableBreaks) {
		params_["disableBreaks"] = disableBreaks
	}
	
	
	
	if !isZero(replMode) {
		params_["replMode"] = replMode
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.evaluate",
		"params": params_,
	})

	var returns_ RuntimeEvaluateReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeGetIsolateIdReturns struct {
	
	Id string
	
}

/* Returns the isolate id. */
func (t *Tab) RuntimeGetIsolateId() (RuntimeGetIsolateIdReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.getIsolateId",
		"params": params_,
	})

	var returns_ RuntimeGetIsolateIdReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeGetHeapUsageReturns struct {
	
	UsedSize float64
	
	TotalSize float64
	
}

/* Returns the JavaScript heap usage.
It is the total usage of the corresponding isolate not scoped to a particular Runtime. */
func (t *Tab) RuntimeGetHeapUsage() (RuntimeGetHeapUsageReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.getHeapUsage",
		"params": params_,
	})

	var returns_ RuntimeGetHeapUsageReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeGetPropertiesReturns struct {
	
	Result []RuntimePropertyDescriptor
	
	InternalProperties []RuntimeInternalPropertyDescriptor
	
	PrivateProperties []RuntimePrivatePropertyDescriptor
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Returns properties of a given object. Object group of the result is inherited from the target
object. */
func (t *Tab) RuntimeGetProperties(objectId RuntimeRemoteObjectId, ownProperties bool, accessorPropertiesOnly bool, generatePreview bool) (RuntimeGetPropertiesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	
	
	if !isZero(ownProperties) {
		params_["ownProperties"] = ownProperties
	}
	
	
	
	if !isZero(accessorPropertiesOnly) {
		params_["accessorPropertiesOnly"] = accessorPropertiesOnly
	}
	
	
	
	if !isZero(generatePreview) {
		params_["generatePreview"] = generatePreview
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.getProperties",
		"params": params_,
	})

	var returns_ RuntimeGetPropertiesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeGlobalLexicalScopeNamesReturns struct {
	
	Names []string
	
}

/* Returns all let, const and class variables from global scope. */
func (t *Tab) RuntimeGlobalLexicalScopeNames(executionContextId RuntimeExecutionContextId) (RuntimeGlobalLexicalScopeNamesReturns, error) {
	params_ := make(map[string]interface{})

	
	
	if !isZero(executionContextId) {
		params_["executionContextId"] = executionContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.globalLexicalScopeNames",
		"params": params_,
	})

	var returns_ RuntimeGlobalLexicalScopeNamesReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeQueryObjectsReturns struct {
	
	Objects RuntimeRemoteObject
	
}

/*  */
func (t *Tab) RuntimeQueryObjects(protoTypeObjectId RuntimeRemoteObjectId, objectGroup string) (RuntimeQueryObjectsReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["protoTypeObjectId"] = protoTypeObjectId
	
	
	
	if !isZero(objectGroup) {
		params_["objectGroup"] = objectGroup
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.queryObjects",
		"params": params_,
	})

	var returns_ RuntimeQueryObjectsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeReleaseObjectReturns struct {
	
}

/* Releases remote object with given id. */
func (t *Tab) RuntimeReleaseObject(objectId RuntimeRemoteObjectId) (RuntimeReleaseObjectReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectId"] = objectId
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.releaseObject",
		"params": params_,
	})

	var returns_ RuntimeReleaseObjectReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeReleaseObjectGroupReturns struct {
	
}

/* Releases all remote objects that belong to a given group. */
func (t *Tab) RuntimeReleaseObjectGroup(objectGroup string) (RuntimeReleaseObjectGroupReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["objectGroup"] = objectGroup
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.releaseObjectGroup",
		"params": params_,
	})

	var returns_ RuntimeReleaseObjectGroupReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeRunIfWaitingForDebuggerReturns struct {
	
}

/* Tells inspected instance to run if it was waiting for debugger to attach. */
func (t *Tab) RuntimeRunIfWaitingForDebugger() (RuntimeRunIfWaitingForDebuggerReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.runIfWaitingForDebugger",
		"params": params_,
	})

	var returns_ RuntimeRunIfWaitingForDebuggerReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeRunScriptReturns struct {
	
	Result RuntimeRemoteObject
	
	ExceptionDetails RuntimeExceptionDetails
	
}

/* Runs script with given id in a given context. */
func (t *Tab) RuntimeRunScript(scriptId RuntimeScriptId, executionContextId RuntimeExecutionContextId, objectGroup string, silent bool, includeCommandLineAPI bool, returnByValue bool, generatePreview bool, awaitPromise bool) (RuntimeRunScriptReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["scriptId"] = scriptId
	
	
	
	if !isZero(executionContextId) {
		params_["executionContextId"] = executionContextId
	}
	
	
	
	if !isZero(objectGroup) {
		params_["objectGroup"] = objectGroup
	}
	
	
	
	if !isZero(silent) {
		params_["silent"] = silent
	}
	
	
	
	if !isZero(includeCommandLineAPI) {
		params_["includeCommandLineAPI"] = includeCommandLineAPI
	}
	
	
	
	if !isZero(returnByValue) {
		params_["returnByValue"] = returnByValue
	}
	
	
	
	if !isZero(generatePreview) {
		params_["generatePreview"] = generatePreview
	}
	
	
	
	if !isZero(awaitPromise) {
		params_["awaitPromise"] = awaitPromise
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.runScript",
		"params": params_,
	})

	var returns_ RuntimeRunScriptReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeSetAsyncCallStackDepthReturns struct {
	
}

/* Enables or disables async call stacks tracking. */
func (t *Tab) RuntimeSetAsyncCallStackDepth(maxDepth int) (RuntimeSetAsyncCallStackDepthReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["maxDepth"] = maxDepth
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.setAsyncCallStackDepth",
		"params": params_,
	})

	var returns_ RuntimeSetAsyncCallStackDepthReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeSetCustomObjectFormatterEnabledReturns struct {
	
}

/*  */
func (t *Tab) RuntimeSetCustomObjectFormatterEnabled(enabled bool) (RuntimeSetCustomObjectFormatterEnabledReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["enabled"] = enabled
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.setCustomObjectFormatterEnabled",
		"params": params_,
	})

	var returns_ RuntimeSetCustomObjectFormatterEnabledReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeSetMaxCallStackSizeToCaptureReturns struct {
	
}

/*  */
func (t *Tab) RuntimeSetMaxCallStackSizeToCapture(size int) (RuntimeSetMaxCallStackSizeToCaptureReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["size"] = size
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.setMaxCallStackSizeToCapture",
		"params": params_,
	})

	var returns_ RuntimeSetMaxCallStackSizeToCaptureReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeTerminateExecutionReturns struct {
	
}

/* Terminate current or next JavaScript execution.
Will cancel the termination when the outer-most script execution ends. */
func (t *Tab) RuntimeTerminateExecution() (RuntimeTerminateExecutionReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.terminateExecution",
		"params": params_,
	})

	var returns_ RuntimeTerminateExecutionReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeAddBindingReturns struct {
	
}

/* If executionContextId is empty, adds binding with the given name on the
global objects of all inspected contexts, including those created later,
bindings survive reloads.
If executionContextId is specified, adds binding only on global object of
given execution context.
Binding function takes exactly one argument, this argument should be string,
in case of any other input, function throws an exception.
Each binding function call produces Runtime.bindingCalled notification. */
func (t *Tab) RuntimeAddBinding(name string, executionContextId RuntimeExecutionContextId) (RuntimeAddBindingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["name"] = name
	
	
	
	if !isZero(executionContextId) {
		params_["executionContextId"] = executionContextId
	}
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.addBinding",
		"params": params_,
	})

	var returns_ RuntimeAddBindingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type RuntimeRemoveBindingReturns struct {
	
}

/* This method does not remove binding function from global object but
unsubscribes current runtime agent from Runtime.bindingCalled notifications. */
func (t *Tab) RuntimeRemoveBinding(name string) (RuntimeRemoveBindingReturns, error) {
	params_ := make(map[string]interface{})

	
	
	params_["name"] = name
	
	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Runtime.removeBinding",
		"params": params_,
	})

	var returns_ RuntimeRemoveBindingReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

type SchemaGetDomainsReturns struct {
	
	Domains []SchemaDomain
	
}

/* Returns supported domains. */
func (t *Tab) SchemaGetDomains() (SchemaGetDomainsReturns, error) {
	params_ := make(map[string]interface{})

	

	ch := t.SendCommand(map[string]interface{}{
		"method": "Schema.getDomains",
		"params": params_,
	})

	var returns_ SchemaGetDomainsReturns
	data_ := <-ch
	err_ := json.Unmarshal(data_, &returns_)
	if err_ != nil {
		return returns_, fmt.Errorf("json.Unmarshal: %w", err_)
	}

	return returns_, nil
}

/* Event Handlers */

type AnimationAnimationCanceledEvent struct {
	
	Id string
	
}
type AnimationAnimationCanceledHandler func (ev AnimationAnimationCanceledEvent)

type AnimationAnimationCreatedEvent struct {
	
	Id string
	
}
type AnimationAnimationCreatedHandler func (ev AnimationAnimationCreatedEvent)

type AnimationAnimationStartedEvent struct {
	
	Animation AnimationAnimation
	
}
type AnimationAnimationStartedHandler func (ev AnimationAnimationStartedEvent)

type ApplicationCacheApplicationCacheStatusUpdatedEvent struct {
	
	FrameId PageFrameId
	
	ManifestURL string
	
	Status int
	
}
type ApplicationCacheApplicationCacheStatusUpdatedHandler func (ev ApplicationCacheApplicationCacheStatusUpdatedEvent)

type ApplicationCacheNetworkStateUpdatedEvent struct {
	
	IsNowOnline bool
	
}
type ApplicationCacheNetworkStateUpdatedHandler func (ev ApplicationCacheNetworkStateUpdatedEvent)

type BackgroundServiceRecordingStateChangedEvent struct {
	
	IsRecording bool
	
	Service BackgroundServiceServiceName
	
}
type BackgroundServiceRecordingStateChangedHandler func (ev BackgroundServiceRecordingStateChangedEvent)

type BackgroundServiceBackgroundServiceEventReceivedEvent struct {
	
	BackgroundServiceEvent BackgroundServiceBackgroundServiceEvent
	
}
type BackgroundServiceBackgroundServiceEventReceivedHandler func (ev BackgroundServiceBackgroundServiceEventReceivedEvent)

type CSSFontsUpdatedEvent struct {
	
	Font CSSFontFace
	
}
type CSSFontsUpdatedHandler func (ev CSSFontsUpdatedEvent)

type CSSMediaQueryResultChangedEvent struct {
	
}
type CSSMediaQueryResultChangedHandler func (ev CSSMediaQueryResultChangedEvent)

type CSSStyleSheetAddedEvent struct {
	
	Header CSSCSSStyleSheetHeader
	
}
type CSSStyleSheetAddedHandler func (ev CSSStyleSheetAddedEvent)

type CSSStyleSheetChangedEvent struct {
	
	StyleSheetId CSSStyleSheetId
	
}
type CSSStyleSheetChangedHandler func (ev CSSStyleSheetChangedEvent)

type CSSStyleSheetRemovedEvent struct {
	
	StyleSheetId CSSStyleSheetId
	
}
type CSSStyleSheetRemovedHandler func (ev CSSStyleSheetRemovedEvent)

type CastSinksUpdatedEvent struct {
	
	Sinks []CastSink
	
}
type CastSinksUpdatedHandler func (ev CastSinksUpdatedEvent)

type CastIssueUpdatedEvent struct {
	
	IssueMessage string
	
}
type CastIssueUpdatedHandler func (ev CastIssueUpdatedEvent)

type DOMAttributeModifiedEvent struct {
	
	NodeId DOMNodeId
	
	Name string
	
	Value string
	
}
type DOMAttributeModifiedHandler func (ev DOMAttributeModifiedEvent)

type DOMAttributeRemovedEvent struct {
	
	NodeId DOMNodeId
	
	Name string
	
}
type DOMAttributeRemovedHandler func (ev DOMAttributeRemovedEvent)

type DOMCharacterDataModifiedEvent struct {
	
	NodeId DOMNodeId
	
	CharacterData string
	
}
type DOMCharacterDataModifiedHandler func (ev DOMCharacterDataModifiedEvent)

type DOMChildNodeCountUpdatedEvent struct {
	
	NodeId DOMNodeId
	
	ChildNodeCount int
	
}
type DOMChildNodeCountUpdatedHandler func (ev DOMChildNodeCountUpdatedEvent)

type DOMChildNodeInsertedEvent struct {
	
	ParentNodeId DOMNodeId
	
	PreviousNodeId DOMNodeId
	
	Node DOMNode
	
}
type DOMChildNodeInsertedHandler func (ev DOMChildNodeInsertedEvent)

type DOMChildNodeRemovedEvent struct {
	
	ParentNodeId DOMNodeId
	
	NodeId DOMNodeId
	
}
type DOMChildNodeRemovedHandler func (ev DOMChildNodeRemovedEvent)

type DOMDistributedNodesUpdatedEvent struct {
	
	InsertionPointId DOMNodeId
	
	DistributedNodes []DOMBackendNode
	
}
type DOMDistributedNodesUpdatedHandler func (ev DOMDistributedNodesUpdatedEvent)

type DOMDocumentUpdatedEvent struct {
	
}
type DOMDocumentUpdatedHandler func (ev DOMDocumentUpdatedEvent)

type DOMInlineStyleInvalidatedEvent struct {
	
	NodeIds []DOMNodeId
	
}
type DOMInlineStyleInvalidatedHandler func (ev DOMInlineStyleInvalidatedEvent)

type DOMPseudoElementAddedEvent struct {
	
	ParentId DOMNodeId
	
	PseudoElement DOMNode
	
}
type DOMPseudoElementAddedHandler func (ev DOMPseudoElementAddedEvent)

type DOMPseudoElementRemovedEvent struct {
	
	ParentId DOMNodeId
	
	PseudoElementId DOMNodeId
	
}
type DOMPseudoElementRemovedHandler func (ev DOMPseudoElementRemovedEvent)

type DOMSetChildNodesEvent struct {
	
	ParentId DOMNodeId
	
	Nodes []DOMNode
	
}
type DOMSetChildNodesHandler func (ev DOMSetChildNodesEvent)

type DOMShadowRootPoppedEvent struct {
	
	HostId DOMNodeId
	
	RootId DOMNodeId
	
}
type DOMShadowRootPoppedHandler func (ev DOMShadowRootPoppedEvent)

type DOMShadowRootPushedEvent struct {
	
	HostId DOMNodeId
	
	Root DOMNode
	
}
type DOMShadowRootPushedHandler func (ev DOMShadowRootPushedEvent)

type DOMStorageDomStorageItemAddedEvent struct {
	
	StorageId DOMStorageStorageId
	
	Key string
	
	NewValue string
	
}
type DOMStorageDomStorageItemAddedHandler func (ev DOMStorageDomStorageItemAddedEvent)

type DOMStorageDomStorageItemRemovedEvent struct {
	
	StorageId DOMStorageStorageId
	
	Key string
	
}
type DOMStorageDomStorageItemRemovedHandler func (ev DOMStorageDomStorageItemRemovedEvent)

type DOMStorageDomStorageItemUpdatedEvent struct {
	
	StorageId DOMStorageStorageId
	
	Key string
	
	OldValue string
	
	NewValue string
	
}
type DOMStorageDomStorageItemUpdatedHandler func (ev DOMStorageDomStorageItemUpdatedEvent)

type DOMStorageDomStorageItemsClearedEvent struct {
	
	StorageId DOMStorageStorageId
	
}
type DOMStorageDomStorageItemsClearedHandler func (ev DOMStorageDomStorageItemsClearedEvent)

type DatabaseAddDatabaseEvent struct {
	
	Database DatabaseDatabase
	
}
type DatabaseAddDatabaseHandler func (ev DatabaseAddDatabaseEvent)

type EmulationVirtualTimeBudgetExpiredEvent struct {
	
}
type EmulationVirtualTimeBudgetExpiredHandler func (ev EmulationVirtualTimeBudgetExpiredEvent)

type HeadlessExperimentalNeedsBeginFramesChangedEvent struct {
	
	NeedsBeginFrames bool
	
}
type HeadlessExperimentalNeedsBeginFramesChangedHandler func (ev HeadlessExperimentalNeedsBeginFramesChangedEvent)

type InspectorDetachedEvent struct {
	
	Reason string
	
}
type InspectorDetachedHandler func (ev InspectorDetachedEvent)

type InspectorTargetCrashedEvent struct {
	
}
type InspectorTargetCrashedHandler func (ev InspectorTargetCrashedEvent)

type InspectorTargetReloadedAfterCrashEvent struct {
	
}
type InspectorTargetReloadedAfterCrashHandler func (ev InspectorTargetReloadedAfterCrashEvent)

type LayerTreeLayerPaintedEvent struct {
	
	LayerId LayerTreeLayerId
	
	Clip DOMRect
	
}
type LayerTreeLayerPaintedHandler func (ev LayerTreeLayerPaintedEvent)

type LayerTreeLayerTreeDidChangeEvent struct {
	
	Layers []LayerTreeLayer
	
}
type LayerTreeLayerTreeDidChangeHandler func (ev LayerTreeLayerTreeDidChangeEvent)

type LogEntryAddedEvent struct {
	
	Entry LogLogEntry
	
}
type LogEntryAddedHandler func (ev LogEntryAddedEvent)

type NetworkDataReceivedEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	DataLength int
	
	EncodedDataLength int
	
}
type NetworkDataReceivedHandler func (ev NetworkDataReceivedEvent)

type NetworkEventSourceMessageReceivedEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	EventName string
	
	EventId string
	
	Data string
	
}
type NetworkEventSourceMessageReceivedHandler func (ev NetworkEventSourceMessageReceivedEvent)

type NetworkLoadingFailedEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	Type NetworkResourceType
	
	ErrorText string
	
	Canceled bool
	
	BlockedReason NetworkBlockedReason
	
}
type NetworkLoadingFailedHandler func (ev NetworkLoadingFailedEvent)

type NetworkLoadingFinishedEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	EncodedDataLength float64
	
	ShouldReportCorbBlocking bool
	
}
type NetworkLoadingFinishedHandler func (ev NetworkLoadingFinishedEvent)

type NetworkRequestInterceptedEvent struct {
	
	InterceptionId NetworkInterceptionId
	
	Request NetworkRequest
	
	FrameId PageFrameId
	
	ResourceType NetworkResourceType
	
	IsNavigationRequest bool
	
	IsDownload bool
	
	RedirectUrl string
	
	AuthChallenge NetworkAuthChallenge
	
	ResponseErrorReason NetworkErrorReason
	
	ResponseStatusCode int
	
	ResponseHeaders NetworkHeaders
	
	RequestId NetworkRequestId
	
}
type NetworkRequestInterceptedHandler func (ev NetworkRequestInterceptedEvent)

type NetworkRequestServedFromCacheEvent struct {
	
	RequestId NetworkRequestId
	
}
type NetworkRequestServedFromCacheHandler func (ev NetworkRequestServedFromCacheEvent)

type NetworkRequestWillBeSentEvent struct {
	
	RequestId NetworkRequestId
	
	LoaderId NetworkLoaderId
	
	DocumentURL string
	
	Request NetworkRequest
	
	Timestamp NetworkMonotonicTime
	
	WallTime NetworkTimeSinceEpoch
	
	Initiator NetworkInitiator
	
	RedirectResponse NetworkResponse
	
	Type NetworkResourceType
	
	FrameId PageFrameId
	
	HasUserGesture bool
	
}
type NetworkRequestWillBeSentHandler func (ev NetworkRequestWillBeSentEvent)

type NetworkResourceChangedPriorityEvent struct {
	
	RequestId NetworkRequestId
	
	NewPriority NetworkResourcePriority
	
	Timestamp NetworkMonotonicTime
	
}
type NetworkResourceChangedPriorityHandler func (ev NetworkResourceChangedPriorityEvent)

type NetworkSignedExchangeReceivedEvent struct {
	
	RequestId NetworkRequestId
	
	Info NetworkSignedExchangeInfo
	
}
type NetworkSignedExchangeReceivedHandler func (ev NetworkSignedExchangeReceivedEvent)

type NetworkResponseReceivedEvent struct {
	
	RequestId NetworkRequestId
	
	LoaderId NetworkLoaderId
	
	Timestamp NetworkMonotonicTime
	
	Type NetworkResourceType
	
	Response NetworkResponse
	
	FrameId PageFrameId
	
}
type NetworkResponseReceivedHandler func (ev NetworkResponseReceivedEvent)

type NetworkWebSocketClosedEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
}
type NetworkWebSocketClosedHandler func (ev NetworkWebSocketClosedEvent)

type NetworkWebSocketCreatedEvent struct {
	
	RequestId NetworkRequestId
	
	Url string
	
	Initiator NetworkInitiator
	
}
type NetworkWebSocketCreatedHandler func (ev NetworkWebSocketCreatedEvent)

type NetworkWebSocketFrameErrorEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	ErrorMessage string
	
}
type NetworkWebSocketFrameErrorHandler func (ev NetworkWebSocketFrameErrorEvent)

type NetworkWebSocketFrameReceivedEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	Response NetworkWebSocketFrame
	
}
type NetworkWebSocketFrameReceivedHandler func (ev NetworkWebSocketFrameReceivedEvent)

type NetworkWebSocketFrameSentEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	Response NetworkWebSocketFrame
	
}
type NetworkWebSocketFrameSentHandler func (ev NetworkWebSocketFrameSentEvent)

type NetworkWebSocketHandshakeResponseReceivedEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	Response NetworkWebSocketResponse
	
}
type NetworkWebSocketHandshakeResponseReceivedHandler func (ev NetworkWebSocketHandshakeResponseReceivedEvent)

type NetworkWebSocketWillSendHandshakeRequestEvent struct {
	
	RequestId NetworkRequestId
	
	Timestamp NetworkMonotonicTime
	
	WallTime NetworkTimeSinceEpoch
	
	Request NetworkWebSocketRequest
	
}
type NetworkWebSocketWillSendHandshakeRequestHandler func (ev NetworkWebSocketWillSendHandshakeRequestEvent)

type NetworkRequestWillBeSentExtraInfoEvent struct {
	
	RequestId NetworkRequestId
	
	BlockedCookies []NetworkBlockedCookieWithReason
	
	Headers NetworkHeaders
	
}
type NetworkRequestWillBeSentExtraInfoHandler func (ev NetworkRequestWillBeSentExtraInfoEvent)

type NetworkResponseReceivedExtraInfoEvent struct {
	
	RequestId NetworkRequestId
	
	BlockedCookies []NetworkBlockedSetCookieWithReason
	
	Headers NetworkHeaders
	
	HeadersText string
	
}
type NetworkResponseReceivedExtraInfoHandler func (ev NetworkResponseReceivedExtraInfoEvent)

type OverlayInspectNodeRequestedEvent struct {
	
	BackendNodeId DOMBackendNodeId
	
}
type OverlayInspectNodeRequestedHandler func (ev OverlayInspectNodeRequestedEvent)

type OverlayNodeHighlightRequestedEvent struct {
	
	NodeId DOMNodeId
	
}
type OverlayNodeHighlightRequestedHandler func (ev OverlayNodeHighlightRequestedEvent)

type OverlayScreenshotRequestedEvent struct {
	
	Viewport PageViewport
	
}
type OverlayScreenshotRequestedHandler func (ev OverlayScreenshotRequestedEvent)

type OverlayInspectModeCanceledEvent struct {
	
}
type OverlayInspectModeCanceledHandler func (ev OverlayInspectModeCanceledEvent)

type PageDomContentEventFiredEvent struct {
	
	Timestamp NetworkMonotonicTime
	
}
type PageDomContentEventFiredHandler func (ev PageDomContentEventFiredEvent)

type PageFileChooserOpenedEvent struct {
	
	FrameId PageFrameId
	
	BackendNodeId DOMBackendNodeId
	
	Mode string
	
}
type PageFileChooserOpenedHandler func (ev PageFileChooserOpenedEvent)

type PageFrameAttachedEvent struct {
	
	FrameId PageFrameId
	
	ParentFrameId PageFrameId
	
	Stack RuntimeStackTrace
	
}
type PageFrameAttachedHandler func (ev PageFrameAttachedEvent)

type PageFrameClearedScheduledNavigationEvent struct {
	
	FrameId PageFrameId
	
}
type PageFrameClearedScheduledNavigationHandler func (ev PageFrameClearedScheduledNavigationEvent)

type PageFrameDetachedEvent struct {
	
	FrameId PageFrameId
	
}
type PageFrameDetachedHandler func (ev PageFrameDetachedEvent)

type PageFrameNavigatedEvent struct {
	
	Frame PageFrame
	
}
type PageFrameNavigatedHandler func (ev PageFrameNavigatedEvent)

type PageFrameResizedEvent struct {
	
}
type PageFrameResizedHandler func (ev PageFrameResizedEvent)

type PageFrameRequestedNavigationEvent struct {
	
	FrameId PageFrameId
	
	Reason PageClientNavigationReason
	
	Url string
	
}
type PageFrameRequestedNavigationHandler func (ev PageFrameRequestedNavigationEvent)

type PageFrameScheduledNavigationEvent struct {
	
	FrameId PageFrameId
	
	Delay float64
	
	Reason string
	
	Url string
	
}
type PageFrameScheduledNavigationHandler func (ev PageFrameScheduledNavigationEvent)

type PageFrameStartedLoadingEvent struct {
	
	FrameId PageFrameId
	
}
type PageFrameStartedLoadingHandler func (ev PageFrameStartedLoadingEvent)

type PageFrameStoppedLoadingEvent struct {
	
	FrameId PageFrameId
	
}
type PageFrameStoppedLoadingHandler func (ev PageFrameStoppedLoadingEvent)

type PageDownloadWillBeginEvent struct {
	
	FrameId PageFrameId
	
	Url string
	
}
type PageDownloadWillBeginHandler func (ev PageDownloadWillBeginEvent)

type PageInterstitialHiddenEvent struct {
	
}
type PageInterstitialHiddenHandler func (ev PageInterstitialHiddenEvent)

type PageInterstitialShownEvent struct {
	
}
type PageInterstitialShownHandler func (ev PageInterstitialShownEvent)

type PageJavascriptDialogClosedEvent struct {
	
	Result bool
	
	UserInput string
	
}
type PageJavascriptDialogClosedHandler func (ev PageJavascriptDialogClosedEvent)

type PageJavascriptDialogOpeningEvent struct {
	
	Url string
	
	Message string
	
	Type PageDialogType
	
	HasBrowserHandler bool
	
	DefaultPrompt string
	
}
type PageJavascriptDialogOpeningHandler func (ev PageJavascriptDialogOpeningEvent)

type PageLifecycleEventEvent struct {
	
	FrameId PageFrameId
	
	LoaderId NetworkLoaderId
	
	Name string
	
	Timestamp NetworkMonotonicTime
	
}
type PageLifecycleEventHandler func (ev PageLifecycleEventEvent)

type PageLoadEventFiredEvent struct {
	
	Timestamp NetworkMonotonicTime
	
}
type PageLoadEventFiredHandler func (ev PageLoadEventFiredEvent)

type PageNavigatedWithinDocumentEvent struct {
	
	FrameId PageFrameId
	
	Url string
	
}
type PageNavigatedWithinDocumentHandler func (ev PageNavigatedWithinDocumentEvent)

type PageScreencastFrameEvent struct {
	
	Data []byte
	
	Metadata PageScreencastFrameMetadata
	
	SessionId int
	
}
type PageScreencastFrameHandler func (ev PageScreencastFrameEvent)

type PageScreencastVisibilityChangedEvent struct {
	
	Visible bool
	
}
type PageScreencastVisibilityChangedHandler func (ev PageScreencastVisibilityChangedEvent)

type PageWindowOpenEvent struct {
	
	Url string
	
	WindowName string
	
	WindowFeatures []string
	
	UserGesture bool
	
}
type PageWindowOpenHandler func (ev PageWindowOpenEvent)

type PageCompilationCacheProducedEvent struct {
	
	Url string
	
	Data []byte
	
}
type PageCompilationCacheProducedHandler func (ev PageCompilationCacheProducedEvent)

type PerformanceMetricsEvent struct {
	
	Metrics []PerformanceMetric
	
	Title string
	
}
type PerformanceMetricsHandler func (ev PerformanceMetricsEvent)

type SecurityCertificateErrorEvent struct {
	
	EventId int
	
	ErrorType string
	
	RequestURL string
	
}
type SecurityCertificateErrorHandler func (ev SecurityCertificateErrorEvent)

type SecurityVisibleSecurityStateChangedEvent struct {
	
	VisibleSecurityState SecurityVisibleSecurityState
	
}
type SecurityVisibleSecurityStateChangedHandler func (ev SecurityVisibleSecurityStateChangedEvent)

type SecuritySecurityStateChangedEvent struct {
	
	SecurityState SecuritySecurityState
	
	SchemeIsCryptographic bool
	
	Explanations []SecuritySecurityStateExplanation
	
	InsecureContentStatus SecurityInsecureContentStatus
	
	Summary string
	
}
type SecuritySecurityStateChangedHandler func (ev SecuritySecurityStateChangedEvent)

type ServiceWorkerWorkerErrorReportedEvent struct {
	
	ErrorMessage ServiceWorkerServiceWorkerErrorMessage
	
}
type ServiceWorkerWorkerErrorReportedHandler func (ev ServiceWorkerWorkerErrorReportedEvent)

type ServiceWorkerWorkerRegistrationUpdatedEvent struct {
	
	Registrations []ServiceWorkerServiceWorkerRegistration
	
}
type ServiceWorkerWorkerRegistrationUpdatedHandler func (ev ServiceWorkerWorkerRegistrationUpdatedEvent)

type ServiceWorkerWorkerVersionUpdatedEvent struct {
	
	Versions []ServiceWorkerServiceWorkerVersion
	
}
type ServiceWorkerWorkerVersionUpdatedHandler func (ev ServiceWorkerWorkerVersionUpdatedEvent)

type StorageCacheStorageContentUpdatedEvent struct {
	
	Origin string
	
	CacheName string
	
}
type StorageCacheStorageContentUpdatedHandler func (ev StorageCacheStorageContentUpdatedEvent)

type StorageCacheStorageListUpdatedEvent struct {
	
	Origin string
	
}
type StorageCacheStorageListUpdatedHandler func (ev StorageCacheStorageListUpdatedEvent)

type StorageIndexedDBContentUpdatedEvent struct {
	
	Origin string
	
	DatabaseName string
	
	ObjectStoreName string
	
}
type StorageIndexedDBContentUpdatedHandler func (ev StorageIndexedDBContentUpdatedEvent)

type StorageIndexedDBListUpdatedEvent struct {
	
	Origin string
	
}
type StorageIndexedDBListUpdatedHandler func (ev StorageIndexedDBListUpdatedEvent)

type TargetAttachedToTargetEvent struct {
	
	SessionId TargetSessionID
	
	TargetInfo TargetTargetInfo
	
	WaitingForDebugger bool
	
}
type TargetAttachedToTargetHandler func (ev TargetAttachedToTargetEvent)

type TargetDetachedFromTargetEvent struct {
	
	SessionId TargetSessionID
	
	TargetId TargetTargetID
	
}
type TargetDetachedFromTargetHandler func (ev TargetDetachedFromTargetEvent)

type TargetReceivedMessageFromTargetEvent struct {
	
	SessionId TargetSessionID
	
	Message string
	
	TargetId TargetTargetID
	
}
type TargetReceivedMessageFromTargetHandler func (ev TargetReceivedMessageFromTargetEvent)

type TargetTargetCreatedEvent struct {
	
	TargetInfo TargetTargetInfo
	
}
type TargetTargetCreatedHandler func (ev TargetTargetCreatedEvent)

type TargetTargetDestroyedEvent struct {
	
	TargetId TargetTargetID
	
}
type TargetTargetDestroyedHandler func (ev TargetTargetDestroyedEvent)

type TargetTargetCrashedEvent struct {
	
	TargetId TargetTargetID
	
	Status string
	
	ErrorCode int
	
}
type TargetTargetCrashedHandler func (ev TargetTargetCrashedEvent)

type TargetTargetInfoChangedEvent struct {
	
	TargetInfo TargetTargetInfo
	
}
type TargetTargetInfoChangedHandler func (ev TargetTargetInfoChangedEvent)

type TetheringAcceptedEvent struct {
	
	Port int
	
	ConnectionId string
	
}
type TetheringAcceptedHandler func (ev TetheringAcceptedEvent)

type TracingBufferUsageEvent struct {
	
	PercentFull float64
	
	EventCount float64
	
	Value float64
	
}
type TracingBufferUsageHandler func (ev TracingBufferUsageEvent)

type TracingDataCollectedEvent struct {
	
	Value []map[string]interface{}
	
}
type TracingDataCollectedHandler func (ev TracingDataCollectedEvent)

type TracingTracingCompleteEvent struct {
	
	DataLossOccurred bool
	
	Stream IOStreamHandle
	
	TraceFormat TracingStreamFormat
	
	StreamCompression TracingStreamCompression
	
}
type TracingTracingCompleteHandler func (ev TracingTracingCompleteEvent)

type FetchRequestPausedEvent struct {
	
	RequestId FetchRequestId
	
	Request NetworkRequest
	
	FrameId PageFrameId
	
	ResourceType NetworkResourceType
	
	ResponseErrorReason NetworkErrorReason
	
	ResponseStatusCode int
	
	ResponseHeaders []FetchHeaderEntry
	
	NetworkId FetchRequestId
	
}
type FetchRequestPausedHandler func (ev FetchRequestPausedEvent)

type FetchAuthRequiredEvent struct {
	
	RequestId FetchRequestId
	
	Request NetworkRequest
	
	FrameId PageFrameId
	
	ResourceType NetworkResourceType
	
	AuthChallenge FetchAuthChallenge
	
}
type FetchAuthRequiredHandler func (ev FetchAuthRequiredEvent)

type WebAudioContextCreatedEvent struct {
	
	Context WebAudioBaseAudioContext
	
}
type WebAudioContextCreatedHandler func (ev WebAudioContextCreatedEvent)

type WebAudioContextWillBeDestroyedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
}
type WebAudioContextWillBeDestroyedHandler func (ev WebAudioContextWillBeDestroyedEvent)

type WebAudioContextChangedEvent struct {
	
	Context WebAudioBaseAudioContext
	
}
type WebAudioContextChangedHandler func (ev WebAudioContextChangedEvent)

type WebAudioAudioListenerCreatedEvent struct {
	
	Listener WebAudioAudioListener
	
}
type WebAudioAudioListenerCreatedHandler func (ev WebAudioAudioListenerCreatedEvent)

type WebAudioAudioListenerWillBeDestroyedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
	ListenerId WebAudioGraphObjectId
	
}
type WebAudioAudioListenerWillBeDestroyedHandler func (ev WebAudioAudioListenerWillBeDestroyedEvent)

type WebAudioAudioNodeCreatedEvent struct {
	
	Node WebAudioAudioNode
	
}
type WebAudioAudioNodeCreatedHandler func (ev WebAudioAudioNodeCreatedEvent)

type WebAudioAudioNodeWillBeDestroyedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
	NodeId WebAudioGraphObjectId
	
}
type WebAudioAudioNodeWillBeDestroyedHandler func (ev WebAudioAudioNodeWillBeDestroyedEvent)

type WebAudioAudioParamCreatedEvent struct {
	
	Param WebAudioAudioParam
	
}
type WebAudioAudioParamCreatedHandler func (ev WebAudioAudioParamCreatedEvent)

type WebAudioAudioParamWillBeDestroyedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
	NodeId WebAudioGraphObjectId
	
	ParamId WebAudioGraphObjectId
	
}
type WebAudioAudioParamWillBeDestroyedHandler func (ev WebAudioAudioParamWillBeDestroyedEvent)

type WebAudioNodesConnectedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
	SourceId WebAudioGraphObjectId
	
	DestinationId WebAudioGraphObjectId
	
	SourceOutputIndex float64
	
	DestinationInputIndex float64
	
}
type WebAudioNodesConnectedHandler func (ev WebAudioNodesConnectedEvent)

type WebAudioNodesDisconnectedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
	SourceId WebAudioGraphObjectId
	
	DestinationId WebAudioGraphObjectId
	
	SourceOutputIndex float64
	
	DestinationInputIndex float64
	
}
type WebAudioNodesDisconnectedHandler func (ev WebAudioNodesDisconnectedEvent)

type WebAudioNodeParamConnectedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
	SourceId WebAudioGraphObjectId
	
	DestinationId WebAudioGraphObjectId
	
	SourceOutputIndex float64
	
}
type WebAudioNodeParamConnectedHandler func (ev WebAudioNodeParamConnectedEvent)

type WebAudioNodeParamDisconnectedEvent struct {
	
	ContextId WebAudioGraphObjectId
	
	SourceId WebAudioGraphObjectId
	
	DestinationId WebAudioGraphObjectId
	
	SourceOutputIndex float64
	
}
type WebAudioNodeParamDisconnectedHandler func (ev WebAudioNodeParamDisconnectedEvent)

type MediaPlayerPropertiesChangedEvent struct {
	
	PlayerId MediaPlayerId
	
	Properties []MediaPlayerProperty
	
}
type MediaPlayerPropertiesChangedHandler func (ev MediaPlayerPropertiesChangedEvent)

type MediaPlayerEventsAddedEvent struct {
	
	PlayerId MediaPlayerId
	
	Events []MediaPlayerEvent
	
}
type MediaPlayerEventsAddedHandler func (ev MediaPlayerEventsAddedEvent)

type MediaPlayersCreatedEvent struct {
	
	Players []MediaPlayerId
	
}
type MediaPlayersCreatedHandler func (ev MediaPlayersCreatedEvent)

type ConsoleMessageAddedEvent struct {
	
	Message ConsoleConsoleMessage
	
}
type ConsoleMessageAddedHandler func (ev ConsoleMessageAddedEvent)

type DebuggerBreakpointResolvedEvent struct {
	
	BreakpointId DebuggerBreakpointId
	
	Location DebuggerLocation
	
}
type DebuggerBreakpointResolvedHandler func (ev DebuggerBreakpointResolvedEvent)

type DebuggerPausedEvent struct {
	
	CallFrames []DebuggerCallFrame
	
	Reason string
	
	Data map[string]interface{}
	
	HitBreakpoints []string
	
	AsyncStackTrace RuntimeStackTrace
	
	AsyncStackTraceId RuntimeStackTraceId
	
	AsyncCallStackTraceId RuntimeStackTraceId
	
}
type DebuggerPausedHandler func (ev DebuggerPausedEvent)

type DebuggerResumedEvent struct {
	
}
type DebuggerResumedHandler func (ev DebuggerResumedEvent)

type DebuggerScriptFailedToParseEvent struct {
	
	ScriptId RuntimeScriptId
	
	Url string
	
	StartLine int
	
	StartColumn int
	
	EndLine int
	
	EndColumn int
	
	ExecutionContextId RuntimeExecutionContextId
	
	Hash string
	
	ExecutionContextAuxData map[string]interface{}
	
	SourceMapURL string
	
	HasSourceURL bool
	
	IsModule bool
	
	Length int
	
	StackTrace RuntimeStackTrace
	
}
type DebuggerScriptFailedToParseHandler func (ev DebuggerScriptFailedToParseEvent)

type DebuggerScriptParsedEvent struct {
	
	ScriptId RuntimeScriptId
	
	Url string
	
	StartLine int
	
	StartColumn int
	
	EndLine int
	
	EndColumn int
	
	ExecutionContextId RuntimeExecutionContextId
	
	Hash string
	
	ExecutionContextAuxData map[string]interface{}
	
	IsLiveEdit bool
	
	SourceMapURL string
	
	HasSourceURL bool
	
	IsModule bool
	
	Length int
	
	StackTrace RuntimeStackTrace
	
}
type DebuggerScriptParsedHandler func (ev DebuggerScriptParsedEvent)

type HeapProfilerAddHeapSnapshotChunkEvent struct {
	
	Chunk string
	
}
type HeapProfilerAddHeapSnapshotChunkHandler func (ev HeapProfilerAddHeapSnapshotChunkEvent)

type HeapProfilerHeapStatsUpdateEvent struct {
	
	StatsUpdate []int
	
}
type HeapProfilerHeapStatsUpdateHandler func (ev HeapProfilerHeapStatsUpdateEvent)

type HeapProfilerLastSeenObjectIdEvent struct {
	
	LastSeenObjectId int
	
	Timestamp float64
	
}
type HeapProfilerLastSeenObjectIdHandler func (ev HeapProfilerLastSeenObjectIdEvent)

type HeapProfilerReportHeapSnapshotProgressEvent struct {
	
	Done int
	
	Total int
	
	Finished bool
	
}
type HeapProfilerReportHeapSnapshotProgressHandler func (ev HeapProfilerReportHeapSnapshotProgressEvent)

type HeapProfilerResetProfilesEvent struct {
	
}
type HeapProfilerResetProfilesHandler func (ev HeapProfilerResetProfilesEvent)

type ProfilerConsoleProfileFinishedEvent struct {
	
	Id string
	
	Location DebuggerLocation
	
	Profile ProfilerProfile
	
	Title string
	
}
type ProfilerConsoleProfileFinishedHandler func (ev ProfilerConsoleProfileFinishedEvent)

type ProfilerConsoleProfileStartedEvent struct {
	
	Id string
	
	Location DebuggerLocation
	
	Title string
	
}
type ProfilerConsoleProfileStartedHandler func (ev ProfilerConsoleProfileStartedEvent)

type RuntimeBindingCalledEvent struct {
	
	Name string
	
	Payload string
	
	ExecutionContextId RuntimeExecutionContextId
	
}
type RuntimeBindingCalledHandler func (ev RuntimeBindingCalledEvent)

type RuntimeConsoleAPICalledEvent struct {
	
	Type string
	
	Args []RuntimeRemoteObject
	
	ExecutionContextId RuntimeExecutionContextId
	
	Timestamp RuntimeTimestamp
	
	StackTrace RuntimeStackTrace
	
	Context string
	
}
type RuntimeConsoleAPICalledHandler func (ev RuntimeConsoleAPICalledEvent)

type RuntimeExceptionRevokedEvent struct {
	
	Reason string
	
	ExceptionId int
	
}
type RuntimeExceptionRevokedHandler func (ev RuntimeExceptionRevokedEvent)

type RuntimeExceptionThrownEvent struct {
	
	Timestamp RuntimeTimestamp
	
	ExceptionDetails RuntimeExceptionDetails
	
}
type RuntimeExceptionThrownHandler func (ev RuntimeExceptionThrownEvent)

type RuntimeExecutionContextCreatedEvent struct {
	
	Context RuntimeExecutionContextDescription
	
}
type RuntimeExecutionContextCreatedHandler func (ev RuntimeExecutionContextCreatedEvent)

type RuntimeExecutionContextDestroyedEvent struct {
	
	ExecutionContextId RuntimeExecutionContextId
	
}
type RuntimeExecutionContextDestroyedHandler func (ev RuntimeExecutionContextDestroyedEvent)

type RuntimeExecutionContextsClearedEvent struct {
	
}
type RuntimeExecutionContextsClearedHandler func (ev RuntimeExecutionContextsClearedEvent)

type RuntimeInspectRequestedEvent struct {
	
	Object RuntimeRemoteObject
	
	Hints map[string]interface{}
	
}
type RuntimeInspectRequestedHandler func (ev RuntimeInspectRequestedEvent)

/* Handle Tab Events */
type tabEventHandlers struct {

	OnAnimationAnimationCanceled AnimationAnimationCanceledHandler

	OnAnimationAnimationCreated AnimationAnimationCreatedHandler

	OnAnimationAnimationStarted AnimationAnimationStartedHandler

	OnApplicationCacheApplicationCacheStatusUpdated ApplicationCacheApplicationCacheStatusUpdatedHandler

	OnApplicationCacheNetworkStateUpdated ApplicationCacheNetworkStateUpdatedHandler

	OnBackgroundServiceRecordingStateChanged BackgroundServiceRecordingStateChangedHandler

	OnBackgroundServiceBackgroundServiceEventReceived BackgroundServiceBackgroundServiceEventReceivedHandler

	OnCSSFontsUpdated CSSFontsUpdatedHandler

	OnCSSMediaQueryResultChanged CSSMediaQueryResultChangedHandler

	OnCSSStyleSheetAdded CSSStyleSheetAddedHandler

	OnCSSStyleSheetChanged CSSStyleSheetChangedHandler

	OnCSSStyleSheetRemoved CSSStyleSheetRemovedHandler

	OnCastSinksUpdated CastSinksUpdatedHandler

	OnCastIssueUpdated CastIssueUpdatedHandler

	OnDOMAttributeModified DOMAttributeModifiedHandler

	OnDOMAttributeRemoved DOMAttributeRemovedHandler

	OnDOMCharacterDataModified DOMCharacterDataModifiedHandler

	OnDOMChildNodeCountUpdated DOMChildNodeCountUpdatedHandler

	OnDOMChildNodeInserted DOMChildNodeInsertedHandler

	OnDOMChildNodeRemoved DOMChildNodeRemovedHandler

	OnDOMDistributedNodesUpdated DOMDistributedNodesUpdatedHandler

	OnDOMDocumentUpdated DOMDocumentUpdatedHandler

	OnDOMInlineStyleInvalidated DOMInlineStyleInvalidatedHandler

	OnDOMPseudoElementAdded DOMPseudoElementAddedHandler

	OnDOMPseudoElementRemoved DOMPseudoElementRemovedHandler

	OnDOMSetChildNodes DOMSetChildNodesHandler

	OnDOMShadowRootPopped DOMShadowRootPoppedHandler

	OnDOMShadowRootPushed DOMShadowRootPushedHandler

	OnDOMStorageDomStorageItemAdded DOMStorageDomStorageItemAddedHandler

	OnDOMStorageDomStorageItemRemoved DOMStorageDomStorageItemRemovedHandler

	OnDOMStorageDomStorageItemUpdated DOMStorageDomStorageItemUpdatedHandler

	OnDOMStorageDomStorageItemsCleared DOMStorageDomStorageItemsClearedHandler

	OnDatabaseAddDatabase DatabaseAddDatabaseHandler

	OnEmulationVirtualTimeBudgetExpired EmulationVirtualTimeBudgetExpiredHandler

	OnHeadlessExperimentalNeedsBeginFramesChanged HeadlessExperimentalNeedsBeginFramesChangedHandler

	OnInspectorDetached InspectorDetachedHandler

	OnInspectorTargetCrashed InspectorTargetCrashedHandler

	OnInspectorTargetReloadedAfterCrash InspectorTargetReloadedAfterCrashHandler

	OnLayerTreeLayerPainted LayerTreeLayerPaintedHandler

	OnLayerTreeLayerTreeDidChange LayerTreeLayerTreeDidChangeHandler

	OnLogEntryAdded LogEntryAddedHandler

	OnNetworkDataReceived NetworkDataReceivedHandler

	OnNetworkEventSourceMessageReceived NetworkEventSourceMessageReceivedHandler

	OnNetworkLoadingFailed NetworkLoadingFailedHandler

	OnNetworkLoadingFinished NetworkLoadingFinishedHandler

	OnNetworkRequestIntercepted NetworkRequestInterceptedHandler

	OnNetworkRequestServedFromCache NetworkRequestServedFromCacheHandler

	OnNetworkRequestWillBeSent NetworkRequestWillBeSentHandler

	OnNetworkResourceChangedPriority NetworkResourceChangedPriorityHandler

	OnNetworkSignedExchangeReceived NetworkSignedExchangeReceivedHandler

	OnNetworkResponseReceived NetworkResponseReceivedHandler

	OnNetworkWebSocketClosed NetworkWebSocketClosedHandler

	OnNetworkWebSocketCreated NetworkWebSocketCreatedHandler

	OnNetworkWebSocketFrameError NetworkWebSocketFrameErrorHandler

	OnNetworkWebSocketFrameReceived NetworkWebSocketFrameReceivedHandler

	OnNetworkWebSocketFrameSent NetworkWebSocketFrameSentHandler

	OnNetworkWebSocketHandshakeResponseReceived NetworkWebSocketHandshakeResponseReceivedHandler

	OnNetworkWebSocketWillSendHandshakeRequest NetworkWebSocketWillSendHandshakeRequestHandler

	OnNetworkRequestWillBeSentExtraInfo NetworkRequestWillBeSentExtraInfoHandler

	OnNetworkResponseReceivedExtraInfo NetworkResponseReceivedExtraInfoHandler

	OnOverlayInspectNodeRequested OverlayInspectNodeRequestedHandler

	OnOverlayNodeHighlightRequested OverlayNodeHighlightRequestedHandler

	OnOverlayScreenshotRequested OverlayScreenshotRequestedHandler

	OnOverlayInspectModeCanceled OverlayInspectModeCanceledHandler

	OnPageDomContentEventFired PageDomContentEventFiredHandler

	OnPageFileChooserOpened PageFileChooserOpenedHandler

	OnPageFrameAttached PageFrameAttachedHandler

	OnPageFrameClearedScheduledNavigation PageFrameClearedScheduledNavigationHandler

	OnPageFrameDetached PageFrameDetachedHandler

	OnPageFrameNavigated PageFrameNavigatedHandler

	OnPageFrameResized PageFrameResizedHandler

	OnPageFrameRequestedNavigation PageFrameRequestedNavigationHandler

	OnPageFrameScheduledNavigation PageFrameScheduledNavigationHandler

	OnPageFrameStartedLoading PageFrameStartedLoadingHandler

	OnPageFrameStoppedLoading PageFrameStoppedLoadingHandler

	OnPageDownloadWillBegin PageDownloadWillBeginHandler

	OnPageInterstitialHidden PageInterstitialHiddenHandler

	OnPageInterstitialShown PageInterstitialShownHandler

	OnPageJavascriptDialogClosed PageJavascriptDialogClosedHandler

	OnPageJavascriptDialogOpening PageJavascriptDialogOpeningHandler

	OnPageLifecycleEvent PageLifecycleEventHandler

	OnPageLoadEventFired PageLoadEventFiredHandler

	OnPageNavigatedWithinDocument PageNavigatedWithinDocumentHandler

	OnPageScreencastFrame PageScreencastFrameHandler

	OnPageScreencastVisibilityChanged PageScreencastVisibilityChangedHandler

	OnPageWindowOpen PageWindowOpenHandler

	OnPageCompilationCacheProduced PageCompilationCacheProducedHandler

	OnPerformanceMetrics PerformanceMetricsHandler

	OnSecurityCertificateError SecurityCertificateErrorHandler

	OnSecurityVisibleSecurityStateChanged SecurityVisibleSecurityStateChangedHandler

	OnSecuritySecurityStateChanged SecuritySecurityStateChangedHandler

	OnServiceWorkerWorkerErrorReported ServiceWorkerWorkerErrorReportedHandler

	OnServiceWorkerWorkerRegistrationUpdated ServiceWorkerWorkerRegistrationUpdatedHandler

	OnServiceWorkerWorkerVersionUpdated ServiceWorkerWorkerVersionUpdatedHandler

	OnStorageCacheStorageContentUpdated StorageCacheStorageContentUpdatedHandler

	OnStorageCacheStorageListUpdated StorageCacheStorageListUpdatedHandler

	OnStorageIndexedDBContentUpdated StorageIndexedDBContentUpdatedHandler

	OnStorageIndexedDBListUpdated StorageIndexedDBListUpdatedHandler

	OnTargetAttachedToTarget TargetAttachedToTargetHandler

	OnTargetDetachedFromTarget TargetDetachedFromTargetHandler

	OnTargetReceivedMessageFromTarget TargetReceivedMessageFromTargetHandler

	OnTargetTargetCreated TargetTargetCreatedHandler

	OnTargetTargetDestroyed TargetTargetDestroyedHandler

	OnTargetTargetCrashed TargetTargetCrashedHandler

	OnTargetTargetInfoChanged TargetTargetInfoChangedHandler

	OnTetheringAccepted TetheringAcceptedHandler

	OnTracingBufferUsage TracingBufferUsageHandler

	OnTracingDataCollected TracingDataCollectedHandler

	OnTracingTracingComplete TracingTracingCompleteHandler

	OnFetchRequestPaused FetchRequestPausedHandler

	OnFetchAuthRequired FetchAuthRequiredHandler

	OnWebAudioContextCreated WebAudioContextCreatedHandler

	OnWebAudioContextWillBeDestroyed WebAudioContextWillBeDestroyedHandler

	OnWebAudioContextChanged WebAudioContextChangedHandler

	OnWebAudioAudioListenerCreated WebAudioAudioListenerCreatedHandler

	OnWebAudioAudioListenerWillBeDestroyed WebAudioAudioListenerWillBeDestroyedHandler

	OnWebAudioAudioNodeCreated WebAudioAudioNodeCreatedHandler

	OnWebAudioAudioNodeWillBeDestroyed WebAudioAudioNodeWillBeDestroyedHandler

	OnWebAudioAudioParamCreated WebAudioAudioParamCreatedHandler

	OnWebAudioAudioParamWillBeDestroyed WebAudioAudioParamWillBeDestroyedHandler

	OnWebAudioNodesConnected WebAudioNodesConnectedHandler

	OnWebAudioNodesDisconnected WebAudioNodesDisconnectedHandler

	OnWebAudioNodeParamConnected WebAudioNodeParamConnectedHandler

	OnWebAudioNodeParamDisconnected WebAudioNodeParamDisconnectedHandler

	OnMediaPlayerPropertiesChanged MediaPlayerPropertiesChangedHandler

	OnMediaPlayerEventsAdded MediaPlayerEventsAddedHandler

	OnMediaPlayersCreated MediaPlayersCreatedHandler

	OnConsoleMessageAdded ConsoleMessageAddedHandler

	OnDebuggerBreakpointResolved DebuggerBreakpointResolvedHandler

	OnDebuggerPaused DebuggerPausedHandler

	OnDebuggerResumed DebuggerResumedHandler

	OnDebuggerScriptFailedToParse DebuggerScriptFailedToParseHandler

	OnDebuggerScriptParsed DebuggerScriptParsedHandler

	OnHeapProfilerAddHeapSnapshotChunk HeapProfilerAddHeapSnapshotChunkHandler

	OnHeapProfilerHeapStatsUpdate HeapProfilerHeapStatsUpdateHandler

	OnHeapProfilerLastSeenObjectId HeapProfilerLastSeenObjectIdHandler

	OnHeapProfilerReportHeapSnapshotProgress HeapProfilerReportHeapSnapshotProgressHandler

	OnHeapProfilerResetProfiles HeapProfilerResetProfilesHandler

	OnProfilerConsoleProfileFinished ProfilerConsoleProfileFinishedHandler

	OnProfilerConsoleProfileStarted ProfilerConsoleProfileStartedHandler

	OnRuntimeBindingCalled RuntimeBindingCalledHandler

	OnRuntimeConsoleAPICalled RuntimeConsoleAPICalledHandler

	OnRuntimeExceptionRevoked RuntimeExceptionRevokedHandler

	OnRuntimeExceptionThrown RuntimeExceptionThrownHandler

	OnRuntimeExecutionContextCreated RuntimeExecutionContextCreatedHandler

	OnRuntimeExecutionContextDestroyed RuntimeExecutionContextDestroyedHandler

	OnRuntimeExecutionContextsCleared RuntimeExecutionContextsClearedHandler

	OnRuntimeInspectRequested RuntimeInspectRequestedHandler

}
func (t *Tab) HandleEvent(method string, params json.RawMessage) error {
	switch method {

	case "Animation.animationCanceled":
		var ev AnimationAnimationCanceledEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Animation.animationCanceled: %s", err)
			return err
		}
		if t.Events.OnAnimationAnimationCanceled != nil {
			go t.Events.OnAnimationAnimationCanceled(ev)
		}

	case "Animation.animationCreated":
		var ev AnimationAnimationCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Animation.animationCreated: %s", err)
			return err
		}
		if t.Events.OnAnimationAnimationCreated != nil {
			go t.Events.OnAnimationAnimationCreated(ev)
		}

	case "Animation.animationStarted":
		var ev AnimationAnimationStartedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Animation.animationStarted: %s", err)
			return err
		}
		if t.Events.OnAnimationAnimationStarted != nil {
			go t.Events.OnAnimationAnimationStarted(ev)
		}

	case "ApplicationCache.applicationCacheStatusUpdated":
		var ev ApplicationCacheApplicationCacheStatusUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("ApplicationCache.applicationCacheStatusUpdated: %s", err)
			return err
		}
		if t.Events.OnApplicationCacheApplicationCacheStatusUpdated != nil {
			go t.Events.OnApplicationCacheApplicationCacheStatusUpdated(ev)
		}

	case "ApplicationCache.networkStateUpdated":
		var ev ApplicationCacheNetworkStateUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("ApplicationCache.networkStateUpdated: %s", err)
			return err
		}
		if t.Events.OnApplicationCacheNetworkStateUpdated != nil {
			go t.Events.OnApplicationCacheNetworkStateUpdated(ev)
		}

	case "BackgroundService.recordingStateChanged":
		var ev BackgroundServiceRecordingStateChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("BackgroundService.recordingStateChanged: %s", err)
			return err
		}
		if t.Events.OnBackgroundServiceRecordingStateChanged != nil {
			go t.Events.OnBackgroundServiceRecordingStateChanged(ev)
		}

	case "BackgroundService.backgroundServiceEventReceived":
		var ev BackgroundServiceBackgroundServiceEventReceivedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("BackgroundService.backgroundServiceEventReceived: %s", err)
			return err
		}
		if t.Events.OnBackgroundServiceBackgroundServiceEventReceived != nil {
			go t.Events.OnBackgroundServiceBackgroundServiceEventReceived(ev)
		}

	case "CSS.fontsUpdated":
		var ev CSSFontsUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("CSS.fontsUpdated: %s", err)
			return err
		}
		if t.Events.OnCSSFontsUpdated != nil {
			go t.Events.OnCSSFontsUpdated(ev)
		}

	case "CSS.mediaQueryResultChanged":
		var ev CSSMediaQueryResultChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("CSS.mediaQueryResultChanged: %s", err)
			return err
		}
		if t.Events.OnCSSMediaQueryResultChanged != nil {
			go t.Events.OnCSSMediaQueryResultChanged(ev)
		}

	case "CSS.styleSheetAdded":
		var ev CSSStyleSheetAddedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("CSS.styleSheetAdded: %s", err)
			return err
		}
		if t.Events.OnCSSStyleSheetAdded != nil {
			go t.Events.OnCSSStyleSheetAdded(ev)
		}

	case "CSS.styleSheetChanged":
		var ev CSSStyleSheetChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("CSS.styleSheetChanged: %s", err)
			return err
		}
		if t.Events.OnCSSStyleSheetChanged != nil {
			go t.Events.OnCSSStyleSheetChanged(ev)
		}

	case "CSS.styleSheetRemoved":
		var ev CSSStyleSheetRemovedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("CSS.styleSheetRemoved: %s", err)
			return err
		}
		if t.Events.OnCSSStyleSheetRemoved != nil {
			go t.Events.OnCSSStyleSheetRemoved(ev)
		}

	case "Cast.sinksUpdated":
		var ev CastSinksUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Cast.sinksUpdated: %s", err)
			return err
		}
		if t.Events.OnCastSinksUpdated != nil {
			go t.Events.OnCastSinksUpdated(ev)
		}

	case "Cast.issueUpdated":
		var ev CastIssueUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Cast.issueUpdated: %s", err)
			return err
		}
		if t.Events.OnCastIssueUpdated != nil {
			go t.Events.OnCastIssueUpdated(ev)
		}

	case "DOM.attributeModified":
		var ev DOMAttributeModifiedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.attributeModified: %s", err)
			return err
		}
		if t.Events.OnDOMAttributeModified != nil {
			go t.Events.OnDOMAttributeModified(ev)
		}

	case "DOM.attributeRemoved":
		var ev DOMAttributeRemovedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.attributeRemoved: %s", err)
			return err
		}
		if t.Events.OnDOMAttributeRemoved != nil {
			go t.Events.OnDOMAttributeRemoved(ev)
		}

	case "DOM.characterDataModified":
		var ev DOMCharacterDataModifiedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.characterDataModified: %s", err)
			return err
		}
		if t.Events.OnDOMCharacterDataModified != nil {
			go t.Events.OnDOMCharacterDataModified(ev)
		}

	case "DOM.childNodeCountUpdated":
		var ev DOMChildNodeCountUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.childNodeCountUpdated: %s", err)
			return err
		}
		if t.Events.OnDOMChildNodeCountUpdated != nil {
			go t.Events.OnDOMChildNodeCountUpdated(ev)
		}

	case "DOM.childNodeInserted":
		var ev DOMChildNodeInsertedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.childNodeInserted: %s", err)
			return err
		}
		if t.Events.OnDOMChildNodeInserted != nil {
			go t.Events.OnDOMChildNodeInserted(ev)
		}

	case "DOM.childNodeRemoved":
		var ev DOMChildNodeRemovedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.childNodeRemoved: %s", err)
			return err
		}
		if t.Events.OnDOMChildNodeRemoved != nil {
			go t.Events.OnDOMChildNodeRemoved(ev)
		}

	case "DOM.distributedNodesUpdated":
		var ev DOMDistributedNodesUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.distributedNodesUpdated: %s", err)
			return err
		}
		if t.Events.OnDOMDistributedNodesUpdated != nil {
			go t.Events.OnDOMDistributedNodesUpdated(ev)
		}

	case "DOM.documentUpdated":
		var ev DOMDocumentUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.documentUpdated: %s", err)
			return err
		}
		if t.Events.OnDOMDocumentUpdated != nil {
			go t.Events.OnDOMDocumentUpdated(ev)
		}

	case "DOM.inlineStyleInvalidated":
		var ev DOMInlineStyleInvalidatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.inlineStyleInvalidated: %s", err)
			return err
		}
		if t.Events.OnDOMInlineStyleInvalidated != nil {
			go t.Events.OnDOMInlineStyleInvalidated(ev)
		}

	case "DOM.pseudoElementAdded":
		var ev DOMPseudoElementAddedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.pseudoElementAdded: %s", err)
			return err
		}
		if t.Events.OnDOMPseudoElementAdded != nil {
			go t.Events.OnDOMPseudoElementAdded(ev)
		}

	case "DOM.pseudoElementRemoved":
		var ev DOMPseudoElementRemovedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.pseudoElementRemoved: %s", err)
			return err
		}
		if t.Events.OnDOMPseudoElementRemoved != nil {
			go t.Events.OnDOMPseudoElementRemoved(ev)
		}

	case "DOM.setChildNodes":
		var ev DOMSetChildNodesEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.setChildNodes: %s", err)
			return err
		}
		if t.Events.OnDOMSetChildNodes != nil {
			go t.Events.OnDOMSetChildNodes(ev)
		}

	case "DOM.shadowRootPopped":
		var ev DOMShadowRootPoppedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.shadowRootPopped: %s", err)
			return err
		}
		if t.Events.OnDOMShadowRootPopped != nil {
			go t.Events.OnDOMShadowRootPopped(ev)
		}

	case "DOM.shadowRootPushed":
		var ev DOMShadowRootPushedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOM.shadowRootPushed: %s", err)
			return err
		}
		if t.Events.OnDOMShadowRootPushed != nil {
			go t.Events.OnDOMShadowRootPushed(ev)
		}

	case "DOMStorage.domStorageItemAdded":
		var ev DOMStorageDomStorageItemAddedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOMStorage.domStorageItemAdded: %s", err)
			return err
		}
		if t.Events.OnDOMStorageDomStorageItemAdded != nil {
			go t.Events.OnDOMStorageDomStorageItemAdded(ev)
		}

	case "DOMStorage.domStorageItemRemoved":
		var ev DOMStorageDomStorageItemRemovedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOMStorage.domStorageItemRemoved: %s", err)
			return err
		}
		if t.Events.OnDOMStorageDomStorageItemRemoved != nil {
			go t.Events.OnDOMStorageDomStorageItemRemoved(ev)
		}

	case "DOMStorage.domStorageItemUpdated":
		var ev DOMStorageDomStorageItemUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOMStorage.domStorageItemUpdated: %s", err)
			return err
		}
		if t.Events.OnDOMStorageDomStorageItemUpdated != nil {
			go t.Events.OnDOMStorageDomStorageItemUpdated(ev)
		}

	case "DOMStorage.domStorageItemsCleared":
		var ev DOMStorageDomStorageItemsClearedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("DOMStorage.domStorageItemsCleared: %s", err)
			return err
		}
		if t.Events.OnDOMStorageDomStorageItemsCleared != nil {
			go t.Events.OnDOMStorageDomStorageItemsCleared(ev)
		}

	case "Database.addDatabase":
		var ev DatabaseAddDatabaseEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Database.addDatabase: %s", err)
			return err
		}
		if t.Events.OnDatabaseAddDatabase != nil {
			go t.Events.OnDatabaseAddDatabase(ev)
		}

	case "Emulation.virtualTimeBudgetExpired":
		var ev EmulationVirtualTimeBudgetExpiredEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Emulation.virtualTimeBudgetExpired: %s", err)
			return err
		}
		if t.Events.OnEmulationVirtualTimeBudgetExpired != nil {
			go t.Events.OnEmulationVirtualTimeBudgetExpired(ev)
		}

	case "HeadlessExperimental.needsBeginFramesChanged":
		var ev HeadlessExperimentalNeedsBeginFramesChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("HeadlessExperimental.needsBeginFramesChanged: %s", err)
			return err
		}
		if t.Events.OnHeadlessExperimentalNeedsBeginFramesChanged != nil {
			go t.Events.OnHeadlessExperimentalNeedsBeginFramesChanged(ev)
		}

	case "Inspector.detached":
		var ev InspectorDetachedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Inspector.detached: %s", err)
			return err
		}
		if t.Events.OnInspectorDetached != nil {
			go t.Events.OnInspectorDetached(ev)
		}

	case "Inspector.targetCrashed":
		var ev InspectorTargetCrashedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Inspector.targetCrashed: %s", err)
			return err
		}
		if t.Events.OnInspectorTargetCrashed != nil {
			go t.Events.OnInspectorTargetCrashed(ev)
		}

	case "Inspector.targetReloadedAfterCrash":
		var ev InspectorTargetReloadedAfterCrashEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Inspector.targetReloadedAfterCrash: %s", err)
			return err
		}
		if t.Events.OnInspectorTargetReloadedAfterCrash != nil {
			go t.Events.OnInspectorTargetReloadedAfterCrash(ev)
		}

	case "LayerTree.layerPainted":
		var ev LayerTreeLayerPaintedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("LayerTree.layerPainted: %s", err)
			return err
		}
		if t.Events.OnLayerTreeLayerPainted != nil {
			go t.Events.OnLayerTreeLayerPainted(ev)
		}

	case "LayerTree.layerTreeDidChange":
		var ev LayerTreeLayerTreeDidChangeEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("LayerTree.layerTreeDidChange: %s", err)
			return err
		}
		if t.Events.OnLayerTreeLayerTreeDidChange != nil {
			go t.Events.OnLayerTreeLayerTreeDidChange(ev)
		}

	case "Log.entryAdded":
		var ev LogEntryAddedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Log.entryAdded: %s", err)
			return err
		}
		if t.Events.OnLogEntryAdded != nil {
			go t.Events.OnLogEntryAdded(ev)
		}

	case "Network.dataReceived":
		var ev NetworkDataReceivedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.dataReceived: %s", err)
			return err
		}
		if t.Events.OnNetworkDataReceived != nil {
			go t.Events.OnNetworkDataReceived(ev)
		}

	case "Network.eventSourceMessageReceived":
		var ev NetworkEventSourceMessageReceivedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.eventSourceMessageReceived: %s", err)
			return err
		}
		if t.Events.OnNetworkEventSourceMessageReceived != nil {
			go t.Events.OnNetworkEventSourceMessageReceived(ev)
		}

	case "Network.loadingFailed":
		var ev NetworkLoadingFailedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.loadingFailed: %s", err)
			return err
		}
		if t.Events.OnNetworkLoadingFailed != nil {
			go t.Events.OnNetworkLoadingFailed(ev)
		}

	case "Network.loadingFinished":
		var ev NetworkLoadingFinishedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.loadingFinished: %s", err)
			return err
		}
		if t.Events.OnNetworkLoadingFinished != nil {
			go t.Events.OnNetworkLoadingFinished(ev)
		}

	case "Network.requestIntercepted":
		var ev NetworkRequestInterceptedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.requestIntercepted: %s", err)
			return err
		}
		if t.Events.OnNetworkRequestIntercepted != nil {
			go t.Events.OnNetworkRequestIntercepted(ev)
		}

	case "Network.requestServedFromCache":
		var ev NetworkRequestServedFromCacheEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.requestServedFromCache: %s", err)
			return err
		}
		if t.Events.OnNetworkRequestServedFromCache != nil {
			go t.Events.OnNetworkRequestServedFromCache(ev)
		}

	case "Network.requestWillBeSent":
		var ev NetworkRequestWillBeSentEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.requestWillBeSent: %s", err)
			return err
		}
		if t.Events.OnNetworkRequestWillBeSent != nil {
			go t.Events.OnNetworkRequestWillBeSent(ev)
		}

	case "Network.resourceChangedPriority":
		var ev NetworkResourceChangedPriorityEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.resourceChangedPriority: %s", err)
			return err
		}
		if t.Events.OnNetworkResourceChangedPriority != nil {
			go t.Events.OnNetworkResourceChangedPriority(ev)
		}

	case "Network.signedExchangeReceived":
		var ev NetworkSignedExchangeReceivedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.signedExchangeReceived: %s", err)
			return err
		}
		if t.Events.OnNetworkSignedExchangeReceived != nil {
			go t.Events.OnNetworkSignedExchangeReceived(ev)
		}

	case "Network.responseReceived":
		var ev NetworkResponseReceivedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.responseReceived: %s", err)
			return err
		}
		if t.Events.OnNetworkResponseReceived != nil {
			go t.Events.OnNetworkResponseReceived(ev)
		}

	case "Network.webSocketClosed":
		var ev NetworkWebSocketClosedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.webSocketClosed: %s", err)
			return err
		}
		if t.Events.OnNetworkWebSocketClosed != nil {
			go t.Events.OnNetworkWebSocketClosed(ev)
		}

	case "Network.webSocketCreated":
		var ev NetworkWebSocketCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.webSocketCreated: %s", err)
			return err
		}
		if t.Events.OnNetworkWebSocketCreated != nil {
			go t.Events.OnNetworkWebSocketCreated(ev)
		}

	case "Network.webSocketFrameError":
		var ev NetworkWebSocketFrameErrorEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.webSocketFrameError: %s", err)
			return err
		}
		if t.Events.OnNetworkWebSocketFrameError != nil {
			go t.Events.OnNetworkWebSocketFrameError(ev)
		}

	case "Network.webSocketFrameReceived":
		var ev NetworkWebSocketFrameReceivedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.webSocketFrameReceived: %s", err)
			return err
		}
		if t.Events.OnNetworkWebSocketFrameReceived != nil {
			go t.Events.OnNetworkWebSocketFrameReceived(ev)
		}

	case "Network.webSocketFrameSent":
		var ev NetworkWebSocketFrameSentEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.webSocketFrameSent: %s", err)
			return err
		}
		if t.Events.OnNetworkWebSocketFrameSent != nil {
			go t.Events.OnNetworkWebSocketFrameSent(ev)
		}

	case "Network.webSocketHandshakeResponseReceived":
		var ev NetworkWebSocketHandshakeResponseReceivedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.webSocketHandshakeResponseReceived: %s", err)
			return err
		}
		if t.Events.OnNetworkWebSocketHandshakeResponseReceived != nil {
			go t.Events.OnNetworkWebSocketHandshakeResponseReceived(ev)
		}

	case "Network.webSocketWillSendHandshakeRequest":
		var ev NetworkWebSocketWillSendHandshakeRequestEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.webSocketWillSendHandshakeRequest: %s", err)
			return err
		}
		if t.Events.OnNetworkWebSocketWillSendHandshakeRequest != nil {
			go t.Events.OnNetworkWebSocketWillSendHandshakeRequest(ev)
		}

	case "Network.requestWillBeSentExtraInfo":
		var ev NetworkRequestWillBeSentExtraInfoEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.requestWillBeSentExtraInfo: %s", err)
			return err
		}
		if t.Events.OnNetworkRequestWillBeSentExtraInfo != nil {
			go t.Events.OnNetworkRequestWillBeSentExtraInfo(ev)
		}

	case "Network.responseReceivedExtraInfo":
		var ev NetworkResponseReceivedExtraInfoEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Network.responseReceivedExtraInfo: %s", err)
			return err
		}
		if t.Events.OnNetworkResponseReceivedExtraInfo != nil {
			go t.Events.OnNetworkResponseReceivedExtraInfo(ev)
		}

	case "Overlay.inspectNodeRequested":
		var ev OverlayInspectNodeRequestedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Overlay.inspectNodeRequested: %s", err)
			return err
		}
		if t.Events.OnOverlayInspectNodeRequested != nil {
			go t.Events.OnOverlayInspectNodeRequested(ev)
		}

	case "Overlay.nodeHighlightRequested":
		var ev OverlayNodeHighlightRequestedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Overlay.nodeHighlightRequested: %s", err)
			return err
		}
		if t.Events.OnOverlayNodeHighlightRequested != nil {
			go t.Events.OnOverlayNodeHighlightRequested(ev)
		}

	case "Overlay.screenshotRequested":
		var ev OverlayScreenshotRequestedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Overlay.screenshotRequested: %s", err)
			return err
		}
		if t.Events.OnOverlayScreenshotRequested != nil {
			go t.Events.OnOverlayScreenshotRequested(ev)
		}

	case "Overlay.inspectModeCanceled":
		var ev OverlayInspectModeCanceledEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Overlay.inspectModeCanceled: %s", err)
			return err
		}
		if t.Events.OnOverlayInspectModeCanceled != nil {
			go t.Events.OnOverlayInspectModeCanceled(ev)
		}

	case "Page.domContentEventFired":
		var ev PageDomContentEventFiredEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.domContentEventFired: %s", err)
			return err
		}
		if t.Events.OnPageDomContentEventFired != nil {
			go t.Events.OnPageDomContentEventFired(ev)
		}

	case "Page.fileChooserOpened":
		var ev PageFileChooserOpenedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.fileChooserOpened: %s", err)
			return err
		}
		if t.Events.OnPageFileChooserOpened != nil {
			go t.Events.OnPageFileChooserOpened(ev)
		}

	case "Page.frameAttached":
		var ev PageFrameAttachedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameAttached: %s", err)
			return err
		}
		if t.Events.OnPageFrameAttached != nil {
			go t.Events.OnPageFrameAttached(ev)
		}

	case "Page.frameClearedScheduledNavigation":
		var ev PageFrameClearedScheduledNavigationEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameClearedScheduledNavigation: %s", err)
			return err
		}
		if t.Events.OnPageFrameClearedScheduledNavigation != nil {
			go t.Events.OnPageFrameClearedScheduledNavigation(ev)
		}

	case "Page.frameDetached":
		var ev PageFrameDetachedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameDetached: %s", err)
			return err
		}
		if t.Events.OnPageFrameDetached != nil {
			go t.Events.OnPageFrameDetached(ev)
		}

	case "Page.frameNavigated":
		var ev PageFrameNavigatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameNavigated: %s", err)
			return err
		}
		if t.Events.OnPageFrameNavigated != nil {
			go t.Events.OnPageFrameNavigated(ev)
		}

	case "Page.frameResized":
		var ev PageFrameResizedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameResized: %s", err)
			return err
		}
		if t.Events.OnPageFrameResized != nil {
			go t.Events.OnPageFrameResized(ev)
		}

	case "Page.frameRequestedNavigation":
		var ev PageFrameRequestedNavigationEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameRequestedNavigation: %s", err)
			return err
		}
		if t.Events.OnPageFrameRequestedNavigation != nil {
			go t.Events.OnPageFrameRequestedNavigation(ev)
		}

	case "Page.frameScheduledNavigation":
		var ev PageFrameScheduledNavigationEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameScheduledNavigation: %s", err)
			return err
		}
		if t.Events.OnPageFrameScheduledNavigation != nil {
			go t.Events.OnPageFrameScheduledNavigation(ev)
		}

	case "Page.frameStartedLoading":
		var ev PageFrameStartedLoadingEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameStartedLoading: %s", err)
			return err
		}
		if t.Events.OnPageFrameStartedLoading != nil {
			go t.Events.OnPageFrameStartedLoading(ev)
		}

	case "Page.frameStoppedLoading":
		var ev PageFrameStoppedLoadingEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.frameStoppedLoading: %s", err)
			return err
		}
		if t.Events.OnPageFrameStoppedLoading != nil {
			go t.Events.OnPageFrameStoppedLoading(ev)
		}

	case "Page.downloadWillBegin":
		var ev PageDownloadWillBeginEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.downloadWillBegin: %s", err)
			return err
		}
		if t.Events.OnPageDownloadWillBegin != nil {
			go t.Events.OnPageDownloadWillBegin(ev)
		}

	case "Page.interstitialHidden":
		var ev PageInterstitialHiddenEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.interstitialHidden: %s", err)
			return err
		}
		if t.Events.OnPageInterstitialHidden != nil {
			go t.Events.OnPageInterstitialHidden(ev)
		}

	case "Page.interstitialShown":
		var ev PageInterstitialShownEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.interstitialShown: %s", err)
			return err
		}
		if t.Events.OnPageInterstitialShown != nil {
			go t.Events.OnPageInterstitialShown(ev)
		}

	case "Page.javascriptDialogClosed":
		var ev PageJavascriptDialogClosedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.javascriptDialogClosed: %s", err)
			return err
		}
		if t.Events.OnPageJavascriptDialogClosed != nil {
			go t.Events.OnPageJavascriptDialogClosed(ev)
		}

	case "Page.javascriptDialogOpening":
		var ev PageJavascriptDialogOpeningEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.javascriptDialogOpening: %s", err)
			return err
		}
		if t.Events.OnPageJavascriptDialogOpening != nil {
			go t.Events.OnPageJavascriptDialogOpening(ev)
		}

	case "Page.lifecycleEvent":
		var ev PageLifecycleEventEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.lifecycleEvent: %s", err)
			return err
		}
		if t.Events.OnPageLifecycleEvent != nil {
			go t.Events.OnPageLifecycleEvent(ev)
		}

	case "Page.loadEventFired":
		var ev PageLoadEventFiredEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.loadEventFired: %s", err)
			return err
		}
		if t.Events.OnPageLoadEventFired != nil {
			go t.Events.OnPageLoadEventFired(ev)
		}

	case "Page.navigatedWithinDocument":
		var ev PageNavigatedWithinDocumentEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.navigatedWithinDocument: %s", err)
			return err
		}
		if t.Events.OnPageNavigatedWithinDocument != nil {
			go t.Events.OnPageNavigatedWithinDocument(ev)
		}

	case "Page.screencastFrame":
		var ev PageScreencastFrameEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.screencastFrame: %s", err)
			return err
		}
		if t.Events.OnPageScreencastFrame != nil {
			go t.Events.OnPageScreencastFrame(ev)
		}

	case "Page.screencastVisibilityChanged":
		var ev PageScreencastVisibilityChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.screencastVisibilityChanged: %s", err)
			return err
		}
		if t.Events.OnPageScreencastVisibilityChanged != nil {
			go t.Events.OnPageScreencastVisibilityChanged(ev)
		}

	case "Page.windowOpen":
		var ev PageWindowOpenEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.windowOpen: %s", err)
			return err
		}
		if t.Events.OnPageWindowOpen != nil {
			go t.Events.OnPageWindowOpen(ev)
		}

	case "Page.compilationCacheProduced":
		var ev PageCompilationCacheProducedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Page.compilationCacheProduced: %s", err)
			return err
		}
		if t.Events.OnPageCompilationCacheProduced != nil {
			go t.Events.OnPageCompilationCacheProduced(ev)
		}

	case "Performance.metrics":
		var ev PerformanceMetricsEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Performance.metrics: %s", err)
			return err
		}
		if t.Events.OnPerformanceMetrics != nil {
			go t.Events.OnPerformanceMetrics(ev)
		}

	case "Security.certificateError":
		var ev SecurityCertificateErrorEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Security.certificateError: %s", err)
			return err
		}
		if t.Events.OnSecurityCertificateError != nil {
			go t.Events.OnSecurityCertificateError(ev)
		}

	case "Security.visibleSecurityStateChanged":
		var ev SecurityVisibleSecurityStateChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Security.visibleSecurityStateChanged: %s", err)
			return err
		}
		if t.Events.OnSecurityVisibleSecurityStateChanged != nil {
			go t.Events.OnSecurityVisibleSecurityStateChanged(ev)
		}

	case "Security.securityStateChanged":
		var ev SecuritySecurityStateChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Security.securityStateChanged: %s", err)
			return err
		}
		if t.Events.OnSecuritySecurityStateChanged != nil {
			go t.Events.OnSecuritySecurityStateChanged(ev)
		}

	case "ServiceWorker.workerErrorReported":
		var ev ServiceWorkerWorkerErrorReportedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("ServiceWorker.workerErrorReported: %s", err)
			return err
		}
		if t.Events.OnServiceWorkerWorkerErrorReported != nil {
			go t.Events.OnServiceWorkerWorkerErrorReported(ev)
		}

	case "ServiceWorker.workerRegistrationUpdated":
		var ev ServiceWorkerWorkerRegistrationUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("ServiceWorker.workerRegistrationUpdated: %s", err)
			return err
		}
		if t.Events.OnServiceWorkerWorkerRegistrationUpdated != nil {
			go t.Events.OnServiceWorkerWorkerRegistrationUpdated(ev)
		}

	case "ServiceWorker.workerVersionUpdated":
		var ev ServiceWorkerWorkerVersionUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("ServiceWorker.workerVersionUpdated: %s", err)
			return err
		}
		if t.Events.OnServiceWorkerWorkerVersionUpdated != nil {
			go t.Events.OnServiceWorkerWorkerVersionUpdated(ev)
		}

	case "Storage.cacheStorageContentUpdated":
		var ev StorageCacheStorageContentUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Storage.cacheStorageContentUpdated: %s", err)
			return err
		}
		if t.Events.OnStorageCacheStorageContentUpdated != nil {
			go t.Events.OnStorageCacheStorageContentUpdated(ev)
		}

	case "Storage.cacheStorageListUpdated":
		var ev StorageCacheStorageListUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Storage.cacheStorageListUpdated: %s", err)
			return err
		}
		if t.Events.OnStorageCacheStorageListUpdated != nil {
			go t.Events.OnStorageCacheStorageListUpdated(ev)
		}

	case "Storage.indexedDBContentUpdated":
		var ev StorageIndexedDBContentUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Storage.indexedDBContentUpdated: %s", err)
			return err
		}
		if t.Events.OnStorageIndexedDBContentUpdated != nil {
			go t.Events.OnStorageIndexedDBContentUpdated(ev)
		}

	case "Storage.indexedDBListUpdated":
		var ev StorageIndexedDBListUpdatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Storage.indexedDBListUpdated: %s", err)
			return err
		}
		if t.Events.OnStorageIndexedDBListUpdated != nil {
			go t.Events.OnStorageIndexedDBListUpdated(ev)
		}

	case "Target.attachedToTarget":
		var ev TargetAttachedToTargetEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Target.attachedToTarget: %s", err)
			return err
		}
		if t.Events.OnTargetAttachedToTarget != nil {
			go t.Events.OnTargetAttachedToTarget(ev)
		}

	case "Target.detachedFromTarget":
		var ev TargetDetachedFromTargetEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Target.detachedFromTarget: %s", err)
			return err
		}
		if t.Events.OnTargetDetachedFromTarget != nil {
			go t.Events.OnTargetDetachedFromTarget(ev)
		}

	case "Target.receivedMessageFromTarget":
		var ev TargetReceivedMessageFromTargetEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Target.receivedMessageFromTarget: %s", err)
			return err
		}
		if t.Events.OnTargetReceivedMessageFromTarget != nil {
			go t.Events.OnTargetReceivedMessageFromTarget(ev)
		}

	case "Target.targetCreated":
		var ev TargetTargetCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Target.targetCreated: %s", err)
			return err
		}
		if t.Events.OnTargetTargetCreated != nil {
			go t.Events.OnTargetTargetCreated(ev)
		}

	case "Target.targetDestroyed":
		var ev TargetTargetDestroyedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Target.targetDestroyed: %s", err)
			return err
		}
		if t.Events.OnTargetTargetDestroyed != nil {
			go t.Events.OnTargetTargetDestroyed(ev)
		}

	case "Target.targetCrashed":
		var ev TargetTargetCrashedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Target.targetCrashed: %s", err)
			return err
		}
		if t.Events.OnTargetTargetCrashed != nil {
			go t.Events.OnTargetTargetCrashed(ev)
		}

	case "Target.targetInfoChanged":
		var ev TargetTargetInfoChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Target.targetInfoChanged: %s", err)
			return err
		}
		if t.Events.OnTargetTargetInfoChanged != nil {
			go t.Events.OnTargetTargetInfoChanged(ev)
		}

	case "Tethering.accepted":
		var ev TetheringAcceptedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Tethering.accepted: %s", err)
			return err
		}
		if t.Events.OnTetheringAccepted != nil {
			go t.Events.OnTetheringAccepted(ev)
		}

	case "Tracing.bufferUsage":
		var ev TracingBufferUsageEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Tracing.bufferUsage: %s", err)
			return err
		}
		if t.Events.OnTracingBufferUsage != nil {
			go t.Events.OnTracingBufferUsage(ev)
		}

	case "Tracing.dataCollected":
		var ev TracingDataCollectedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Tracing.dataCollected: %s", err)
			return err
		}
		if t.Events.OnTracingDataCollected != nil {
			go t.Events.OnTracingDataCollected(ev)
		}

	case "Tracing.tracingComplete":
		var ev TracingTracingCompleteEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Tracing.tracingComplete: %s", err)
			return err
		}
		if t.Events.OnTracingTracingComplete != nil {
			go t.Events.OnTracingTracingComplete(ev)
		}

	case "Fetch.requestPaused":
		var ev FetchRequestPausedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Fetch.requestPaused: %s", err)
			return err
		}
		if t.Events.OnFetchRequestPaused != nil {
			go t.Events.OnFetchRequestPaused(ev)
		}

	case "Fetch.authRequired":
		var ev FetchAuthRequiredEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Fetch.authRequired: %s", err)
			return err
		}
		if t.Events.OnFetchAuthRequired != nil {
			go t.Events.OnFetchAuthRequired(ev)
		}

	case "WebAudio.contextCreated":
		var ev WebAudioContextCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.contextCreated: %s", err)
			return err
		}
		if t.Events.OnWebAudioContextCreated != nil {
			go t.Events.OnWebAudioContextCreated(ev)
		}

	case "WebAudio.contextWillBeDestroyed":
		var ev WebAudioContextWillBeDestroyedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.contextWillBeDestroyed: %s", err)
			return err
		}
		if t.Events.OnWebAudioContextWillBeDestroyed != nil {
			go t.Events.OnWebAudioContextWillBeDestroyed(ev)
		}

	case "WebAudio.contextChanged":
		var ev WebAudioContextChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.contextChanged: %s", err)
			return err
		}
		if t.Events.OnWebAudioContextChanged != nil {
			go t.Events.OnWebAudioContextChanged(ev)
		}

	case "WebAudio.audioListenerCreated":
		var ev WebAudioAudioListenerCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.audioListenerCreated: %s", err)
			return err
		}
		if t.Events.OnWebAudioAudioListenerCreated != nil {
			go t.Events.OnWebAudioAudioListenerCreated(ev)
		}

	case "WebAudio.audioListenerWillBeDestroyed":
		var ev WebAudioAudioListenerWillBeDestroyedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.audioListenerWillBeDestroyed: %s", err)
			return err
		}
		if t.Events.OnWebAudioAudioListenerWillBeDestroyed != nil {
			go t.Events.OnWebAudioAudioListenerWillBeDestroyed(ev)
		}

	case "WebAudio.audioNodeCreated":
		var ev WebAudioAudioNodeCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.audioNodeCreated: %s", err)
			return err
		}
		if t.Events.OnWebAudioAudioNodeCreated != nil {
			go t.Events.OnWebAudioAudioNodeCreated(ev)
		}

	case "WebAudio.audioNodeWillBeDestroyed":
		var ev WebAudioAudioNodeWillBeDestroyedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.audioNodeWillBeDestroyed: %s", err)
			return err
		}
		if t.Events.OnWebAudioAudioNodeWillBeDestroyed != nil {
			go t.Events.OnWebAudioAudioNodeWillBeDestroyed(ev)
		}

	case "WebAudio.audioParamCreated":
		var ev WebAudioAudioParamCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.audioParamCreated: %s", err)
			return err
		}
		if t.Events.OnWebAudioAudioParamCreated != nil {
			go t.Events.OnWebAudioAudioParamCreated(ev)
		}

	case "WebAudio.audioParamWillBeDestroyed":
		var ev WebAudioAudioParamWillBeDestroyedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.audioParamWillBeDestroyed: %s", err)
			return err
		}
		if t.Events.OnWebAudioAudioParamWillBeDestroyed != nil {
			go t.Events.OnWebAudioAudioParamWillBeDestroyed(ev)
		}

	case "WebAudio.nodesConnected":
		var ev WebAudioNodesConnectedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.nodesConnected: %s", err)
			return err
		}
		if t.Events.OnWebAudioNodesConnected != nil {
			go t.Events.OnWebAudioNodesConnected(ev)
		}

	case "WebAudio.nodesDisconnected":
		var ev WebAudioNodesDisconnectedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.nodesDisconnected: %s", err)
			return err
		}
		if t.Events.OnWebAudioNodesDisconnected != nil {
			go t.Events.OnWebAudioNodesDisconnected(ev)
		}

	case "WebAudio.nodeParamConnected":
		var ev WebAudioNodeParamConnectedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.nodeParamConnected: %s", err)
			return err
		}
		if t.Events.OnWebAudioNodeParamConnected != nil {
			go t.Events.OnWebAudioNodeParamConnected(ev)
		}

	case "WebAudio.nodeParamDisconnected":
		var ev WebAudioNodeParamDisconnectedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("WebAudio.nodeParamDisconnected: %s", err)
			return err
		}
		if t.Events.OnWebAudioNodeParamDisconnected != nil {
			go t.Events.OnWebAudioNodeParamDisconnected(ev)
		}

	case "Media.playerPropertiesChanged":
		var ev MediaPlayerPropertiesChangedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Media.playerPropertiesChanged: %s", err)
			return err
		}
		if t.Events.OnMediaPlayerPropertiesChanged != nil {
			go t.Events.OnMediaPlayerPropertiesChanged(ev)
		}

	case "Media.playerEventsAdded":
		var ev MediaPlayerEventsAddedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Media.playerEventsAdded: %s", err)
			return err
		}
		if t.Events.OnMediaPlayerEventsAdded != nil {
			go t.Events.OnMediaPlayerEventsAdded(ev)
		}

	case "Media.playersCreated":
		var ev MediaPlayersCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Media.playersCreated: %s", err)
			return err
		}
		if t.Events.OnMediaPlayersCreated != nil {
			go t.Events.OnMediaPlayersCreated(ev)
		}

	case "Console.messageAdded":
		var ev ConsoleMessageAddedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Console.messageAdded: %s", err)
			return err
		}
		if t.Events.OnConsoleMessageAdded != nil {
			go t.Events.OnConsoleMessageAdded(ev)
		}

	case "Debugger.breakpointResolved":
		var ev DebuggerBreakpointResolvedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Debugger.breakpointResolved: %s", err)
			return err
		}
		if t.Events.OnDebuggerBreakpointResolved != nil {
			go t.Events.OnDebuggerBreakpointResolved(ev)
		}

	case "Debugger.paused":
		var ev DebuggerPausedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Debugger.paused: %s", err)
			return err
		}
		if t.Events.OnDebuggerPaused != nil {
			go t.Events.OnDebuggerPaused(ev)
		}

	case "Debugger.resumed":
		var ev DebuggerResumedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Debugger.resumed: %s", err)
			return err
		}
		if t.Events.OnDebuggerResumed != nil {
			go t.Events.OnDebuggerResumed(ev)
		}

	case "Debugger.scriptFailedToParse":
		var ev DebuggerScriptFailedToParseEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Debugger.scriptFailedToParse: %s", err)
			return err
		}
		if t.Events.OnDebuggerScriptFailedToParse != nil {
			go t.Events.OnDebuggerScriptFailedToParse(ev)
		}

	case "Debugger.scriptParsed":
		var ev DebuggerScriptParsedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Debugger.scriptParsed: %s", err)
			return err
		}
		if t.Events.OnDebuggerScriptParsed != nil {
			go t.Events.OnDebuggerScriptParsed(ev)
		}

	case "HeapProfiler.addHeapSnapshotChunk":
		var ev HeapProfilerAddHeapSnapshotChunkEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("HeapProfiler.addHeapSnapshotChunk: %s", err)
			return err
		}
		if t.Events.OnHeapProfilerAddHeapSnapshotChunk != nil {
			go t.Events.OnHeapProfilerAddHeapSnapshotChunk(ev)
		}

	case "HeapProfiler.heapStatsUpdate":
		var ev HeapProfilerHeapStatsUpdateEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("HeapProfiler.heapStatsUpdate: %s", err)
			return err
		}
		if t.Events.OnHeapProfilerHeapStatsUpdate != nil {
			go t.Events.OnHeapProfilerHeapStatsUpdate(ev)
		}

	case "HeapProfiler.lastSeenObjectId":
		var ev HeapProfilerLastSeenObjectIdEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("HeapProfiler.lastSeenObjectId: %s", err)
			return err
		}
		if t.Events.OnHeapProfilerLastSeenObjectId != nil {
			go t.Events.OnHeapProfilerLastSeenObjectId(ev)
		}

	case "HeapProfiler.reportHeapSnapshotProgress":
		var ev HeapProfilerReportHeapSnapshotProgressEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("HeapProfiler.reportHeapSnapshotProgress: %s", err)
			return err
		}
		if t.Events.OnHeapProfilerReportHeapSnapshotProgress != nil {
			go t.Events.OnHeapProfilerReportHeapSnapshotProgress(ev)
		}

	case "HeapProfiler.resetProfiles":
		var ev HeapProfilerResetProfilesEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("HeapProfiler.resetProfiles: %s", err)
			return err
		}
		if t.Events.OnHeapProfilerResetProfiles != nil {
			go t.Events.OnHeapProfilerResetProfiles(ev)
		}

	case "Profiler.consoleProfileFinished":
		var ev ProfilerConsoleProfileFinishedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Profiler.consoleProfileFinished: %s", err)
			return err
		}
		if t.Events.OnProfilerConsoleProfileFinished != nil {
			go t.Events.OnProfilerConsoleProfileFinished(ev)
		}

	case "Profiler.consoleProfileStarted":
		var ev ProfilerConsoleProfileStartedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Profiler.consoleProfileStarted: %s", err)
			return err
		}
		if t.Events.OnProfilerConsoleProfileStarted != nil {
			go t.Events.OnProfilerConsoleProfileStarted(ev)
		}

	case "Runtime.bindingCalled":
		var ev RuntimeBindingCalledEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.bindingCalled: %s", err)
			return err
		}
		if t.Events.OnRuntimeBindingCalled != nil {
			go t.Events.OnRuntimeBindingCalled(ev)
		}

	case "Runtime.consoleAPICalled":
		var ev RuntimeConsoleAPICalledEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.consoleAPICalled: %s", err)
			return err
		}
		if t.Events.OnRuntimeConsoleAPICalled != nil {
			go t.Events.OnRuntimeConsoleAPICalled(ev)
		}

	case "Runtime.exceptionRevoked":
		var ev RuntimeExceptionRevokedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.exceptionRevoked: %s", err)
			return err
		}
		if t.Events.OnRuntimeExceptionRevoked != nil {
			go t.Events.OnRuntimeExceptionRevoked(ev)
		}

	case "Runtime.exceptionThrown":
		var ev RuntimeExceptionThrownEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.exceptionThrown: %s", err)
			return err
		}
		if t.Events.OnRuntimeExceptionThrown != nil {
			go t.Events.OnRuntimeExceptionThrown(ev)
		}

	case "Runtime.executionContextCreated":
		var ev RuntimeExecutionContextCreatedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.executionContextCreated: %s", err)
			return err
		}
		if t.Events.OnRuntimeExecutionContextCreated != nil {
			go t.Events.OnRuntimeExecutionContextCreated(ev)
		}

	case "Runtime.executionContextDestroyed":
		var ev RuntimeExecutionContextDestroyedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.executionContextDestroyed: %s", err)
			return err
		}
		if t.Events.OnRuntimeExecutionContextDestroyed != nil {
			go t.Events.OnRuntimeExecutionContextDestroyed(ev)
		}

	case "Runtime.executionContextsCleared":
		var ev RuntimeExecutionContextsClearedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.executionContextsCleared: %s", err)
			return err
		}
		if t.Events.OnRuntimeExecutionContextsCleared != nil {
			go t.Events.OnRuntimeExecutionContextsCleared(ev)
		}

	case "Runtime.inspectRequested":
		var ev RuntimeInspectRequestedEvent
		err := json.Unmarshal(params, &ev)
		if err != nil {
			Log("Runtime.inspectRequested: %s", err)
			return err
		}
		if t.Events.OnRuntimeInspectRequested != nil {
			go t.Events.OnRuntimeInspectRequested(ev)
		}

	default:
		return errEventNotHandled
	}
	return nil
}

